#!title:    Y组合子使用说明书
#!date:     2016-09-05
#!authors:  Mikukonai
#!cover:    
#!type:     原创
#!tags:     函数式编程,计算机科学

#!content

> 在许多高级语言中都有匿名的一等函数。本文介绍了一等函数背后的理论基础——λ演算，以及在λ演算的语境下，如何借助“Y组合子”实现匿名函数的递归，从而揭示λ演算蕴含的强大能力。

# 匿名函数与λ演算

在JavaScript、Java、Ruby等高级编程语言中，有一种被称为“匿名函数”或者是“lambda函数”的特性。这种特性可以使得函数作为值来使用和传递，并且不需要有名字就可以直接调用。这种把函数当作值来使用的特性，称为“一等函数”。

许多人入门编程，是从C这样的纯过程式语言开始的。在这类语言中，函数作为过程，不能被当作值来使用。然而，事实上，“一等函数”的思想比Fortran和C语言要早得多。因此，我们首先来了解一下“一等函数”思想的源头——1930年诞生的**λ演算**（λ-calculus）。

λ演算是阿隆佐·丘奇（Alonzo Church，1903\~1995）在研究一阶逻辑的判定性问题时，发明的一套符号推理系统。λ演算非常简洁，只有三种语法形式和三条推理规则。但正是这样一个简单的系统，却具有强大的计算能力。1936年，丘奇的学生**阿兰·图灵**（Alan M. Turing，1912\~1954），证明了λ演算与他设计的著名的**图灵机**在计算能力上是等价的。

这篇文章的目的，就是从**匿名函数递归**这个看似不可能的问题出发，向各位介绍奇妙的**Y组合子**，证明使用λ演算实现递归的可能性，从而展示出简单的λ演算蕴含的强大能力。

作为预备知识，我们简单了解一下λ演算的规则。规则并不复杂，请安心阅读。

和我们熟悉的一阶演算一样，λ演算也是一种符号演算系统。它的表达式称为“项”，项只有三种语法形式：

- **符号**：任何有效的名字
- **函数**：(**lambda** (%%symbol%%...) %%term%%)
- **调用**：(%%term%%...)

这里采用的语法形式和“正统”的λ演算有所不同。我们使用的形式，实际上完全等同于Scheme语言的语法形式。尽管语法细节不同，但核心的形式是一致的。也就是说，完全可以用JS或者其他语言去表达λ演算。

在λ演算中，每个函数都定义了一个“**作用域**”。在参数列表中出现的符号，就是作用域中有效的“变量”，可以在作用域内部的函数体中使用。由于函数体内还可以嵌套其他函数，因此在内层函数中定义的变量，会“覆盖”外层函数定义的同名变量。例如，表达式`(lambda (x) (lambda (x) x))`中，出现在函数体的`x`，实际上是内层的那个`x`，而不是外层的那个。

根据定义所在的位置，变量分为两种：

- **自由变量**指在函数体中出现，但是没有在本级函数参数列表中出现的符号。
- **约束变量**指的是在函数体中出现，且在本级函数参数列表中出现的符号。

例如，对于表达式`(lambda (x) (lambda (y) (+ x y)))`的内层函数`(lambda (y) (+ x y))`而言，`x`就是它的**自由变量**；而对于整个外层函数来说，它又是**约束变量**。

约束变量可以看作是形式参数，而自由变量可以视为“全局变量”。

λ演算的符号变换规则只有简单的三条：

- **α-变换**：在不覆盖到同一作用域内部的自由变量的前提下，约束变量的名字可以任意替换。

```:lisp
(lambda (阿猫) [阿猫]) = (lambda (阿狗) [阿狗])
```

- **β-归约**：可以用λ项去“调用”一个函数，方法是将函数体内出现的所有有效的（没有被内层函数覆盖的）参数约束变量都替换成λ项。β-归约过程，实际上就是“函数调用”（apply/call/invoke）背后的规则。

```:lisp
[(lambda (x) T) 喵] => T[x→喵]
```

- **η-变换**：可以将任何λ项作抽象，封装成λ函数。

```:lisp
f := (λ (x) (f x))
```

是不是很简洁呢？为了检验你对λ演算的掌握情况，这里有两个λ表达式，不妨尝试手工推导一下。

+ `(((lambda (x y) (lambda (z) y)) z x) y)`→x
+ `(((lambda (x) ((lambda (x) x) (lambda (y) x))) y) x)`→y

如此简洁的系统，怎么可能有强大如图灵机的能力？在过程式语言中，一般都会提供循环、跳转等特性，用来实现较为复杂的带有递归的过程。而λ演算甚至连名字都没有，怎么能实现递归呢？考虑到递归函数的定义里面需要调用自己，或者说需要用自己的表达式去替换自己，但这样一来，自己的表达式里面还是有一个需要替换自己的自己……这样来看，匿名函数递归，貌似是不可能的事情。

所以是时候研究一下这个问题了：匿名函数究竟能否实现递归？

![真正的λ函数，即便没有名字，也能求出他的值。（画师：infinote，PixivID：54853954）](./image/misc/iwazaru.jpg)

# 递归与无穷

递归涉及自指，可以是直接的自指，也可以是间接的自指，也就是转了一圈又回去的自指。比如说，词典告诉你，死循环就是“无限循环”，但是当你翻到无限循环的时候，你发现词典的解释是“死循环”……好一个“死循环”是“死循环”！

这样的自指毕竟无伤大雅，只是没什么用处罢了。但就是自指带来的一个小问题，触发了逻辑学的bug，导致了第三次数学危机，彻底改变了人们对于逻辑学乃至整个数学的理解。

这个问题就是著名的“**罗素悖论**”。英国哲学家罗素（Bertrand Russell，1872—1970）构造了一个集合$S$：$S$由所有不属于**它自己**的元素构成，那么请问，$S$是否属于$S$？

很明显，如果$S$属于$S$，它就违反了自己的定义，因而$S$不应属于$S$。但如果$S$不属于$S$，则根据$S$的定义，$S$又应当属于$S$。矛盾！

这个矛盾涉及集合论的根本问题，集合论的大厦瞬间坍塌。好在这个矛盾的的存在并不会对逻辑的上层建筑产生严重的影响，只需做一些修修补补的工作，就可以维护数学大厦的稳定。这个bug最大的意义是，为人类认识逻辑的本质提供了一个绝佳的切入点。后来的**哥德尔**（Kurt Gödel，1906-1978）和图灵先后用各自的方式解释了这个bug。图灵的工作更具有现实意义——以他的图灵机为基础，开启了一个异彩纷呈的空前的信息时代。

可见，自指是一个危险又有趣的东西。一旦涉及自指，如果不事先掌握某些更高层次上的东西，就很难办。比如匿名的递归函数，如果不事先给它起一个名字，它就很难定义它自己。

因此，问题的关键在于，如何处理递归函数中涉及的自我指涉。

# 高阶函数与不动点

![MIT Scheme 图标（[图片来源](http://groups.csail.mit.edu/mac/projects/scheme/)）](http://groups.csail.mit.edu/mac/projects/scheme/schlogo-250.png)

为了方便，我们暂时允许对匿名函数命名。但是需要强调的是，“命名”这一行为并不是λ演算的一部分，即便λ表达式中引用了“名字”，也只是为了说明方便，可以看成是C语言里面的宏。或者也可以说，“命名”是λ演算的“元语言”。

从最简单的阶乘函数开始入手吧。我们的任务是**找到阶乘函数的λ表达形式**。

首先，假设阶乘函数的名字是“fact”，写成伪·λ表达式是：

```:Scheme
fact =
(lambda (n)
  (if (= n 1)
      1
      (* n (fact (- n 1)))))
```

再次强调，`fact`这个符号是λ函数的一个“代号”，它并不是纯粹的λ变量。为了消除这个不纯粹的“名字”，我们可以利用**η-变换**，将`fact`抽象成`f`，得到

```:Scheme
FACT =
(lambda (f)
  (lambda (n)
    (if (= n 1)
        1
        (* n (f (- n 1))))))
```

有了`f`，`FACT`就完全合乎λ演算的规则了。由于`FACT`接收函数作为参数，因此称为`fact`的“**高阶函数**”。但问题在于，原本的可以接收一个整数作为参数的`fact`，变成了一个需要接收一个函数作为参数的`FACT`了，跟我们想要的“真正的”阶乘函数还不一样。

不过我们可以发现，只要把`fact`代入`FACT`的参数`f`一次，就相当于完成了一次递归。而实际上由于`fact`里面包含了自身，因此被包含的自身内部再次包含了自身……无穷无尽。这也就是说，`(FACT fact)`一次调用的结果，结果是“收敛”于“真正”的`fact`自身的，也就是我们需要的λ演算的阶乘函数。这也就是说：

```:Scheme
fact <=> (FACT fact)
```

在这里，`FACT`是良构的λ表达式，而真正的`fact`暂时还没有写成严格的λ形式。因此，我们的任务就是，根据这个特性，找到`fact`的λ表达形式。这也是我们的最终目标。

为了找到`fact`的λ表达式，我们先来了解**不动点**的概念。

不动点在数学中是一个非常重要的概念。一个最简单的例子是：在计算器上随便按一个数字，反复按cos键，总会得到一个固定的数值（弧度制下是0.739085...）。这是因为这个值是方程$\mathrm{cos}(x) = x$的根。这个过程如下图所示：

![余弦函数的不动点](./image/misc/cos_fixed_point.jpg)

满足`(F x) = x`的`x`，就是`F`的不动点。不动点的概念是广泛的。例如，函数exp就是微分算子d/dx(·)的不动点。可见，我们寻找的`fact`的真正表达式，就是`FACT`的不动点。推而广之，我们可以说，**递归函数的λ表达式，就是其高阶函数的不动点。**

于是我们的问题就变成：如何求取高阶函数的不动点？

# 不动点组合子

所谓的“不动点组合子”，指的是可以求取高阶函数不动点的函数算子。即：

```:scheme
(FIX F) = (F (FIX F))
```

**Y不动点组合子**，简称**Y组合子**，是哈斯卡·柯里（Haskell Curry，1900-1982）构造的一个巧妙的λ表达式。使用它，能够构造出高阶函数对应的递归函数。它的形式是：

```:Scheme
Y =
(lambda (S)
  ( (lambda (x) (S (x x)))
    (lambda (x) (S (x x))) ) )
```

观察发现，里面有奇怪的自调用模式`(x x)`。这个模式称为发散组合子，是Y组合子实现递归的关键，因为它显然模拟了我们之前所说的“自身当中包含自身”的无限嵌套（也就是所谓的“发散”）。

很容易验证，Y组合子的确可以构造出满足`(F x) = x`的真·递归函数：

```:Scheme
Y F = [λf. (λx. f (x x)) (λx. f (x x))] F ; 要进去了哦
    = (λx. F (x x)) (λx. F (x x))  ; 第一个 x x 模式出现啦，让我们apply一下~
    = F ( (λx. F (x x)) (λx. F (x x)) ) ; 咦怎么还有，右边的怎么跟上面的一样，那不如用 Y F 换掉
    = F (Y F) ; 呃… 怎么又是Y F？
```

Y组合子的存在构造性地证明，λ演算完全可以实现匿名函数递归。但是实际上，我们距离真正实现匿名函数的递归，还有一点问题要解决，那就是`(x x)`带来的不收敛的隐患。

# 实际语言中的Y组合子

为了讲清楚`(x x)`为什么会导致不收敛，我们有必要对λ演算在实际语言中的语义实现，做一点探讨。

复杂的λ表达式通过符号推导，变成不可继续推导的简单λ项的过程，称为“归约”或“求值”。在过程式语言中，程序的执行是从头到尾依次进行的，这就是“求值顺序”。在复杂的λ表达式中，如果函数调用的实际参数，也是比较复杂的λ表达式，那么这些表达式也是需要求值的。实际语言中，有这样几种归约（求值）策略：

- 应用序求值/按值调用（call-by-value）：先求出参数的“值”，再用值进行β-归约。例如：

```:Scheme
((lambda (x y) (+ x y)) (* 3 3) (* 4 4))
((lambda (x y) (+ x y)) 9 16)
(+ 9 16)
25
```

- 正则序求值：不求值参数上的λ表达式，先进行β-归约，将所有参数保留原形代入函数，完全展开后再统一求值。例如：

```:Scheme
((lambda (x y) (+ x y)) (* 3 3) (* 4 4))
(+ (* 3 3) (* 4 4))
(+ 9 16)
25
```

- 按需调用（延迟求值/懒惰求值）：这种策略可以说是前述两种策略的一个折中，在不同的具体语言中有不同的操作语义。最为典型的就是Scheme的`if`表达式，此结构并不会积极地求值每个参数，更不会把所有参数都推迟到完全展开后再计算，而是根据条件的真值，“选择”一项进行求值。

应用序求值/按值调用是绝大多数编程语言所采用的求值策略。在Scheme等语言中，Y组合子中的`(x x)`作为`(S (x x))`的参数，会被首先求值，而求值`(x x)`又会导致真·递归函数的过早的表达式展开，由于不是在业务逻辑中调用这个真·递归函数，导致无法满足出口条件，不能收敛。因此，这里应当避免对于`(x x)`的过早求值。为了延迟求值，我们再次利用η-变换，把它封装成一个λ函数`(lambda (y) ((x x) y))`。这是一个“原子”级别的元素，在被求值时，它就像被鸟吃进肚子的果实的种子，不会发生变化，而被原样输出。只有在业务逻辑中调用构造出的递归函数的时候，它才会被展开，而此时有了递归停止条件，就可以停止。

用于应用序求值的Y组合子，称为**Z组合子**。

现在，我们可以用一个实际的例子来运行我们的Y（Z）组合子了：

<code id="z-cb" style="display:none;">(display "10的阶乘：") (newline) (display (((lambda (S) ((lambda (x) (S (lambda (y) ((x x) y)))) (lambda (x) (S (lambda (y) ((x x) y)))))) (lambda (f) (lambda (n) (if (= n 0) 1 (* n (f (- n 1))))))) 10))</code>

> 例子：使用Z组合子计算10的阶乘。

> ```:lisp
(display "10的阶乘：")
(((lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y))))))
 (lambda (f)
     (lambda (n)
       (if (= n 0)
           1
           (* n (f (- n 1))))))) 10)
```

> : <button id="js00" onclick="try{alert(mrRun(getCode('z-cb')));}catch(err){alert(err);}" class="md-button">执行</button>

尽管是用Scheme写成的，但实际上是被编译为JavaScript后，在你的浏览器上执行的。JavaScript原本就是一门以Scheme为参照的语言，它在很多方面都有Scheme的影子，因此JavaScript其实是一门非常棒的学习函数式编程的语言。

# 无穷的Y

一等函数是许多高级语言都具备的特性，也是函数式编程的核心思想之一。一等函数思想和函数式编程的源头是丘奇发明的λ演算。通过本文介绍的Y组合子，看起来很简陋的λ演算，也可以实现递归函数，乃至具备和图灵机一样强大的计算能力。

不动点组合子的存在，意味着λ演算的确是足够强大的，但这并不意味着我们一定要使用它去书写递归程序。既然匿名函数可以通过不动点组合子实现递归，那么我们何必拘泥于“匿名”这一限制呢？直接赋予λ项以“名字”，岂不是更方便？于是，我们**终于可以安心地在编程语言中使用`(define ..)`这样的机制，给函数和各种各样的对象起名字，并且引用它们了**。不动点组合子，就是我们用来认识“名字”的深层意义的阶梯。

![你的名字？](./image/misc/omaedare.jpg)

事实上，λ演算并非最简洁的图灵完备系统。[SKI组合子](https://en.wikipedia.org/wiki/SKI_combinator_calculus)系统、标签系统、元胞自动机、甚至PPT，都具备和λ演算一样强大的能力，都可以实现递归，互相模拟彼此的行为。不动点组合子和这些同等强大的计算模型，能够帮助我们看清“名字”的本质。但是，自我指涉和互相模拟，似乎构成了一个无穷无尽的循环，似乎不能带领我们更进一步，不能带领我们突破计算的“极限”。

> 在登上高处后，就必须把梯子扔掉。必须超越这些命题，然后才会正确看待世界。
——维特根斯坦《逻辑哲学论》，命题6.54

在我们熟悉的代码的背后，有着深邃而奇妙的数理逻辑背景。Y组合子就像是镶嵌在数理逻辑天空中的一颗闪闪发光的星星，我们可以无视它，甚至不需要知道它的存在。但正是这一颗一颗闪烁着智慧之光的星星，共同点亮了计算机科学璀璨的星空，点亮了我们探索无穷的路。

为什么要仰望星空呢？因为星星就在那里呀。

# 参考资料选录

----

+ [Y组合子使用说明书](#)
+ [计算的本质](https://book.douban.com/subject/26148763/)
+ [A Tutorial Introduction to the Lambda Calculus](http://www.inf.fu-berlin.de/inst/ag-ki/rojas_home/documents/tutorials/lambda.pdf)
+ [维基百科 - Fixed-point combinator](https://en.wikipedia.org/wiki/Fixed-point_combinator)
+ [类型与程序设计语言](https://book.douban.com/subject/1318672/)

# 其他推荐文章

------

- [λ演算与丘奇编码](./church-encoding.html)
- [一条永恒的金带](./egb1.html)

> 2016年09月05日 第一版
2018年09月18日 最终版

#!style

#!script

#!script:./js/mikurec2.js

function getCode(divId) {
    return $('#' + divId).html();
}