
#!title:    节拍速度BPM计算
#!date:     2018-11-30
#!authors:  Mikukonai
#!cover:    ./image/cover/52498633_p0.jpg
#!type:     原创
#!tags:     音乐

#!content

# 自相关函数算法

: <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="https://music.163.com/outchain/player?type=2&id=4934355&auto=0&height=32"></iframe>

测试用曲：黒翼は～と，其BPM为100。数据显式地写在本页源代码中（js变量`const kurotsubasa`），其参数如下：

|参数|值|
|-------|
|采样率|44100Hz|
|采样起点|全曲约1/4处|
|帧宽|1024点|
|帧重叠|无|
|帧数|1024帧|
|能量算法|采样对数平方积分|
|时长|23.777s|
|BPM范围|0~1292|

算法：

+ 从原曲1/4长度开始，对原始PCM采样进行分帧。
+ 对每一帧计算能量，计算方法为$E = \sum_{i \in [0,FrameLength)}{ (\log_{10}{sample_i})^2}$
+ 得到长度为1024的能量值序列。
+ 计算能量值序列的自相关序列。
+ 到这一步，就可以通过数序列上的小突起的数目来计算BPM，但是这样做不够自动化，所以继续处理。
+ 对自相关序列做FFT，去掉直流分量后IFFT回去，得到不含直流偏置的自相关序列，此时的自相关序列呈现出明显的周期性。
+ 为了求出这个周期，对其再做一次FFT，得到频谱。
+ 由于自相关序列的频率和原始信号的频率是一致的，而原始的能量值序列的采样率是2584BPM，故自相关序列的“采样率”也是2584BPM。
+ 根据采样定理，频谱宽度为1292BPM。
+ 计算出频谱峰值所在的位置，按比例与1292进行换算，即可得到BPM值。

点击按钮查看演示：

: <button id="bpm" class="MikumarkButton" style="width:100%;">计算BPM</button>

自相关序列（滤除直流分量的。这里数出峰值的数目，再结合采样时长23.777s就可以算出BPM了）

<canvas id="time" style="width:330px; height:150px;" width="330" height="150"></canvas>

其频谱（注意观察极大值点，呈现明显的倍频关系）

<canvas id="freq" style="width:330px; height:150px;" width="330" height="150"></canvas>

# 以下是2015年方案

# 缘起

2015年，折腾过一段时间的Vocaloid。调曲子之前，首先要知道曲子的速度，也就是BPM值。BPM是“拍每分钟”的简写，即一分钟内有多少拍。一般来说，可以用手动计时打拍子的方式来计算BPM。但那时正在学习信号与系统这门课程，于是就想用程序实现。

当时用星之所在、黑翼之心等两三首曲子测试，效果还不错。但由于方案非常粗糙，在一些节奏不那么分明的曲子上，结果就很离谱了，后来就没有再继续研究下去。昨天突然想到这个东西，所以今天重新安装了VS2008，用20多首曲子重新测了一下，写成这篇文章，简单记录一下结果。

# 算法与实现

## 思路

![星の在り処 频谱](./image/misc/hoshinoarika-spectrum.png)

其实一句话就够了……就是对声谱图求一次频谱，取最值点对应的频率为BPM结果。

算法的输入是WAV格式（无压缩PCM）的音频文件，推荐参数如下（其他的没测过）

- 采样率：44100Hz
- 位深：16bit
- 声道数：2

程序解析出采样率、位深等关键参数之后，从音频原长约1/4处开始读取PCM采样点，分别对L、R、LR取平均三个声道分帧、求频谱。

若帧宽1024点，在采样率为44100Hz情况下，每一帧时长为23ms左右。连续取2048帧的频谱（长度约47ms），对每一帧的频谱求取能量，得到能量-时间谱。

对能量-时间谱作FFT，取最值点所在位置对应的实际频率，经换算得到BPM。

总的来说，这种思路是基于一个很简单的假设，即通过音量的强弱变化频率，来确定音乐的速度。

看上面的频谱，是不是有很明显的节奏？大概就是这样。不过这里实现的思路还是太粗糙了一点，只是简单地对每一帧的频谱做积分，而丢失了频谱分布的信息。频谱分布应该是特别重要的，例如规律出现的、在所有频段均匀分布的噪音，可以认为是铜片乐器的声音，这是重要的节奏特征。低频的律动往往代表鼓等打击乐器奠定的基础节奏，都是非常重要的信息。

自相关函数可以提取出随机序列中隐含的周期性信息，因而可以用来解决这个问题。

## 实现细节

- WAV属于RIFF格式，RIFF的解析有相通之处，当然更多地是依赖于具体的媒体类型。
- 手写的基2FFT只能处理1024、256这样的对数为偶数的点数，但测试时使用了2048这个点数，可能有风险。
- 计算频谱能量实际上就是取自然对数后求平均，不知道这样做有没有物理意义。声学上的东西我所知不多，这块可以优化一下，使之在物理上更严谨。
- 最后……其实我根本不懂C++（哭

# 测试与分析

曲子是根据个人口味选的。其实为严谨起见，应该选择多种不同风格、不同类型的曲子去测试。

表格中“倍频”指的是曲子的实际BPM可能不是表格里列出的数，而是为了方便对比，将实际BPM都倍频成和计算得到的BPM相近的数值。我个人认为BPM的合理倍频应该是允许的，只是音符的“分数”有区别。

|测试曲目|艺术家|计算BPM|实测BPM<br>（倍频）|
|---------------------------|
|My Soul|July|171.593|172|
|春のかたみ|元ちとせ|140.050|140|
|星の在り処|伴奏|162.761|163|
|星の在り処（FC初回特典）|う～み|40.3748|40.75|
|星の在り処|う～み|162.761|163|
|黒翼は～と|内藤侑史|100.306|100|
|God knows|平野綾|150.144|150|
|LEVEL5 -judgelight-|fripSide|278.838|280|
|桜·華·彩|?|140.050|140|
|好日子|宋祖英|286.408|288|
|YELL|いきものがかり|150.144|150|
|不离|银临|256.127|256|
|凌云城之围（奇迹暖暖原声）|?|280.100|280|
|春来发几枝|泠鸢yousa|156.452|156|
|光るなら|Goose house|160.237|160|
|シャンランラン|miwa|270.006|270|
|素敵だね（FFX版）|Rikki|140.05|141|
|again|YUI|280.1|280|
|LIFE|YUI|229.631|230|
|雨だれの歌|久保ユリカ等|232.155|234|
|裁梦为魂|银临|0|70|
|是风动|银临|36.5896|40.5|
|蝶梦花雾雨（奇迹暖暖原声）|v.k克|32.8045|30.5|
|君をのせて|久木田薫|34.0662|34.5|

结果分析：可见，BPM落在某一范围内，效果较好。当然，效果主要是取决于曲子本身。像《裁梦为魂》，手动打拍子测BPM的时候，就觉得很不准确，所以也不必苛责算法。更重要的是，许多曲子的节奏、速度并不是全曲统一的，甚至有自由节奏的，在这种情况下，（全曲的）BPM是没有意义的。

总体来看，结果是令人满意的。

# 改进展望

特征工程方面的改进，上面已经提了一些。从算法角度来讲，可以引入一些序列挖掘、聚类的算法，甚至引入RNN等。

有时间可以找几篇文章调研一下，不过目前没有太大的兴趣。

# 代码

以下是描述WAV文件结构的头文件。

```:C
///////////////////////////////////////////////////
// BPM Analyzer
// WAV文件格式解析
// WAV.h
//
// 创建日期 2015.06.09
// 完成日期 2015.06.--
///////////////////////////////////////////////////

#include <fstream>

using namespace std;

#ifndef _BA_WAV_H_
#define _BA_WAV_H_

#define DWORD unsigned int
#define WORD unsigned short
// RIFF文件头结构
struct RIFF_HEADER
{
	// 0x00 RIFF块标识
	char RiffID[4];  // 'R','I','F','F'
	// 0x04 从下一字节开始的文件长度
	DWORD RiffSize;
	// 0x08 WAVE标识
	char RiffFormat[4]; // 'W','A','V','E'
};


struct WAVE_FORMAT
{
	// 0x0c FMT块标识
	char  FmtID[4]; // 'f','m','t',' '
	// 0x10 格式描述块长度，16或18
	DWORD  FmtSize;

	// 以下为格式描述块，长度为16或18，由FmtSize描述。

	// 0x14 编码方式，1为PCM
	WORD FormatTag;
	// 声道数
	WORD Channels;
	// 采样率
	DWORD SamplesPerSec;
	// 字节流量
	DWORD BytesPerSec;
	// 块对齐，每帧字节数
	WORD BlockAlign;
	// 每帧的位数
	WORD BitsPerSample;
};

#endif
```

以下是复数类：

```:c
///////////////////////////////////////////////////
// BPM Analyzer
// 复数类
// Complex.h
//
// 创建日期 2015.06.08
// 完成日期 2015.06.09
///////////////////////////////////////////////////

#ifndef _BA_COMPLEX_H_
#define _BA_COMPLEX_H_

#include <cmath>

class Complex
{

private:

	// 实部和虚部
	double RealPart;
	double ImaginaryPart;

public:

	// 默认构造函数
	Complex()
	{
		this->RealPart = 0.0;
		this->ImaginaryPart = 0.0;
	}

	// 构造函数
	Complex(double rep, double imp)
	{
		this->RealPart = rep;
		this->ImaginaryPart = imp;
	}

	// 直接置数
	void Update(double ReP, double ImP)
	{
		this->RealPart = ReP;
		this->ImaginaryPart = ImP;
	}

	// 取实部
	double Re(void)
	{
		return this->RealPart;
	}

	//取虚部
	double Im(void)
	{
		return this->ImaginaryPart;
	}

	//取模的平方
	double AbsSqr(void)
	{
		return (this->RealPart * this->RealPart + this->ImaginaryPart * this->ImaginaryPart);
	}

	//取模
	double Abs(void)
	{
		return sqrt(this->RealPart * this->RealPart + this->ImaginaryPart * this->ImaginaryPart);
	}

	// 复数加法
	Complex operator+( Complex c )
	{
		return Complex(this->RealPart + c.Re(), this->ImaginaryPart + c.Im() );
	}

	// 复数减法
	Complex operator-( Complex c )
	{
		return Complex(this->RealPart - c.Re(), this->ImaginaryPart - c.Im() );
	}

	// 复数乘法
	Complex operator*( Complex c )
	{
		double rep = this->RealPart * c.Re() - this->ImaginaryPart * c.Im();
		double imp = this->RealPart * c.Im() + c.Re() * this->ImaginaryPart;
		return Complex(rep, imp);
	}

	// 重载赋值运算符
	void operator=( Complex rv )
	{
		this->RealPart = rv.Re();
		this->ImaginaryPart = rv.Im();
	}
};

#endif
```

以下是FFT：

```:C
///////////////////////////////////////////////////
// BPM Analyzer
// 快速傅立叶变换（FFT）
// FFT.h
//
// 采用基-2DIT算法
//
// 创建日期 2015.06.08
// 完成日期 2015.06.09
///////////////////////////////////////////////////

#include "Complex.h"
#include <cmath>

#ifndef _BA_FFT_H_
#define _BA_FFT_H_

// 最大FFT样本数
#define MAX_FFT_SIZE 4096

#define PI 3.14159265358979323846

// 指数计算
const int POW[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536};

// 旋转因子
static Complex W[MAX_FFT_SIZE/2];

// 对数计算（以2为底）
int LOG(int n)
{
	switch(n)
	{
	case 1:return 0; break;
	case 2:return 1; break;
	case 4:return 2; break;
	case 8:return 3; break;
	case 16:return 4; break;
	case 32:return 5; break;
	case 64:return 6; break;
	case 128:return 7; break;
	case 256:return 8; break;
	case 512:return 9; break;
	case 1024:return 10; break;
	case 2048:return 11; break;
	case 4096:return 12; break;
	case 8192:return 13; break;
	case 16384:return 14; break;
	case 32768:return 15; break;
	case 65536:return 16; break;
	default:return -1;
	}
}

// 旋转因子的生成
void GenerateRotationFactor( int size )
{
	double ReP = 0.0;
	double ImP = 0.0;
	// W[i] = exp(-2*pi*j*(i/N))
	// 只需要用到0~（Size-1）的旋转因子
	for(int i = 0; i < size/2 ; i++)
	{
		// 欧拉公式展开
		ReP = cos(2.0 * PI * ( (double)i / (double)size ) );
		ImP = -sin(2.0 * PI * ( (double)i / (double)size ) );
		Complex temp(ReP, ImP);
		W[i] = temp;
	}
}

// 复数数组复制
void ArrayCopy(Complex dest[], Complex src[], int size)
{
	for(int i = 0; i < size; i++)
	{
		dest[i] = src[i];
	}
}

// 码位倒置
void BitReverse(int inIndex[], int indexSize)
{
	int temp = 0;
	int bitSize = LOG(indexSize);
	for(int i = 0; i < indexSize; i++)
	{
		temp = inIndex[i];
		inIndex[i] = 0;
		for(int c = 0; c < bitSize; c++)
		{
			//temp >>= c;
			if((temp>>c) & 1)
			{
				inIndex[i] += POW[bitSize - 1 - c];
			}
		}
	}
}

// 快速傅立叶变换
void FFT(Complex IN[], Complex OUT[], int Size)
{
	Complex buf[2][MAX_FFT_SIZE];
	// 两个数组，用来交替存储各级蝶形运算的结果
	// Complex bufA[MAX_FFT_SIZE];
	// Complex bufB[MAX_FFT_SIZE];

//==== 循环控制变量 =========================================

	// 1.序列长度
	// int Size; （形参）

	// 2.序列长度的对数
	int M = LOG(Size);

	// 3.运算级
	int Level = 0;

	// 4.子序列的组号
	int Group = 0;

	// 5.子序列内的元素下标
	// int i = 0; (循环内部有效)
//==== 循环控制变量如上 =====================================

	// 码位倒置后的输入序列下标
	int indexIn[MAX_FFT_SIZE];

//==== 对输入序列的下标采取码位倒置操作 =====================
	// 先按顺序初始化下标数组
	for(int i = 0; i < MAX_FFT_SIZE; i++)
	{
		indexIn[i] = i;
	}
	// 执行码位倒置
	BitReverse(indexIn, Size);
	// 此时的indexIn[]数组就是码位倒置后的下标
//==== 码位倒置操作完成 =====================================

//==== 计算旋转因子备用 =====================================
	GenerateRotationFactor(Size);
//==== 旋转因子计算完成 =====================================

	// FFT核心算法开始

	// 算法说明
	// 一、输入序列长度为【Size】，其对数为【M】；
	// 二、共有M个运算级【Level】；
	// 三、每级运算有 POW[M-Level-1] 组【Group】子序列参与蝶形运算，子序列长度为POW[Level+1]；
	// 四、每组子序列只有前半部分作为蝶形运算的“首元”，子序列前半部分的长度为 POW[Level]；
	// 五、每组子序列有 POW[Level] 个蝶形运算结，即子序列前半部分（首元）个数；
	// 六、每个蝶形运算结需要使用位于子序列前半部分的一个元素（首元）和对应的后半部分元素（次元），次元下标=首元下标+POW[Level]；
	// 七、每级运算都是以bufA[]作输入、bufB[]作结果；
	// 八、每完成一级运算，均需要将bufB[]拷贝到bufA[]以供下级运算使用。

	// 开始主循环
	// 首先对每一级运算进行循环。共需要循环M级。
	for(Level = 0; Level < M; Level++)
	{
		// 对该级运算中的每组子序列进行蝶形运算的遍历。共需要遍历POW[M-Level-1]个子序列。
		for(Group = 0; Group < POW[M-Level-1]; Group++)
		{
			// 对子序列的前半部分进行元素遍历
			// 每次遍历完成一个基本的蝶形运算结
			for(int i = 0; i < POW[Level]; i++)
			{
				// 下标临时变量
				// 该变量记录蝶形运算的绝对位置
				//   因为i仅仅是子序列前半部分内的元素下标，范围是0~POW[Level]
				//   由于每个子序列的长度是POW[Level+1]，所以
				//     绝对下标 = 组内相对下标i + 组偏移量Group*POW[Level+1]。
				int indexBuf = i + Group * POW[Level+1];

				// 旋转因子上标的计算
				// 旋转因子上标放缩倍数 = 当前运算级的子序列组数
				int ScalingFactor = POW[M-Level-1];


				// 蝶形运算结。FFT算法核心中的核心。

				// 若为第零级运算
				// 第零级运算使用的是码位倒置后的输入序列
				// 运算结果按照原下标（码位倒置前的下标）存入bufB[]
				//   因为后续的运算顺序控制都是基于自然数序下标进行的
				if(Level == 0)
				{
					buf[0][        indexBuf       ] = IN[indexIn[indexBuf]] + W[i*ScalingFactor] * IN[indexIn[indexBuf+POW[Level]]];
					buf[0][ indexBuf + POW[Level] ] = IN[indexIn[indexBuf]] - W[i*ScalingFactor] * IN[indexIn[indexBuf+POW[Level]]];
				}
				// 若为其余级运算
				else
				{
					buf[Level%2][        indexBuf       ] = buf[(Level+1)%2][indexBuf] + W[i*ScalingFactor] * buf[(Level+1)%2][indexBuf+POW[Level]];
					buf[Level%2][ indexBuf + POW[Level] ] = buf[(Level+1)%2][indexBuf] - W[i*ScalingFactor] * buf[(Level+1)%2][indexBuf+POW[Level]];
				}
			} // 对子序列的蝶形运算结束。共计算POW[Level]个蝶形运算结。

		} // 子序列遍历结束。共循环POW[M-Level-1]次。

		// 将bufB[]中的运算结果拷贝至bufA[]
		//ArrayCopy(bufA, bufB, Size);


	} // 运算级循环结束。共循环M次。

	// 将最后一级运算结果从bufB拷贝到OUT
	ArrayCopy(OUT, buf[(Level+1)%2], Size);

} // FFT结束。

#endif
```

以下是主函数，思路主要在这里体现。

```:c
#include "Complex.h"
#include "FFT.h"
#include "WAV.h"

#include <iostream>
#include <fstream>
#include <tchar.h>

using namespace std;

short frameL[4096];
short frameR[4096];

Complex frameLComplex[4096];
Complex frameRComplex[4096];
Complex frameAComplex[4096];

Complex INL[4096];
Complex OUTL[4096];

Complex INR[4096];
Complex OUTR[4096];

Complex INA[4096];
Complex OUTA[4096];

Complex IN[4096];
Complex OUT[4096];

Complex BeatSpectrumL[10][1024];
Complex BeatSpectrumR[10][1024];
Complex BeatSpectrumA[10][1024];


int main()
{
	cout<<"BPM Analyzer"<<endl;
	
	int SampleRate = 0;
	int FrameLength = 0;
	int BeatsLength = 0;

	RIFF_HEADER riff_h;
	WAVE_FORMAT wave_fmt;
	RIFF_HEADER *priff_h = &riff_h;
	WAVE_FORMAT *pwave_fmt = &wave_fmt;

	char* path = "E://150.God knows.wav";

	setlocale(LC_ALL,"Chinese-simplified");
	ifstream Wave(path, ios::binary);
	setlocale(LC_ALL,"C");

	if(!Wave) {
		cout<<"文件打开失败！"<<endl;
		return -1;
	}

	cout << "读取文件 " << path << endl << endl;

	int i = 1000;

	Wave.read((char*)priff_h, sizeof(RIFF_HEADER));
	Wave.read((char*)pwave_fmt, sizeof(WAVE_FORMAT));


	cout<<"文件长度: "<<priff_h->RiffSize<<" Bytes"<<endl;
	cout<<" FMT长度: "<<pwave_fmt->FmtSize<<" Bytes"<<endl<<endl;
	
	cout<<"编码方式: "<<pwave_fmt->FormatTag<<endl;
	cout<<"声 道 数: "<<pwave_fmt->Channels<<endl;
	cout<<"采样位深: "<<pwave_fmt->BitsPerSample<<" bits"<<endl;
	cout<<"采样频率: "<<pwave_fmt->SamplesPerSec<<" Hz"<<endl;
	cout<<"位    速: "<<pwave_fmt->BytesPerSec * 8<<" bps"<<endl<<endl;

	int sampleNumbers = (priff_h->RiffSize - 4 - pwave_fmt->FmtSize - 4) / pwave_fmt->Channels / (pwave_fmt->BitsPerSample / 8);
	cout << "采 样 数: " << sampleNumbers << " samples" << endl;
	int seconds = sampleNumbers / pwave_fmt->SamplesPerSec;
	cout << "时    长: " << seconds << " sec" << endl << endl;

	SampleRate = pwave_fmt->SamplesPerSec;

	int beats = 0;

	Wave.seekg(12 + 8 + pwave_fmt->FmtSize + 3 + priff_h->RiffSize / 4, ios::beg);

	WORD sampleL = 0;
	WORD sampleR = 0;

	double diffSumL = 0.0;
	double diffSumR = 0.0;
	double diffSumA = 0.0;

	FrameLength = 1024;
	BeatsLength = 2048;

	long sampleCount = 0;

	while(!(Wave.eof()))
	{
		// 读取一帧长度的PCM采样
		for(int i = 0; i < FrameLength; i++)
		{
			Wave.read((char*)&sampleL, 2);
			Wave.read((char*)&sampleR, 2); sampleCount++;
			frameL[i] = (short)(sampleL);
			frameR[i] = (short)(sampleR);
			frameLComplex[i].Update((double)frameL[i], 0.0);
			frameRComplex[i].Update((double)frameR[i], 0.0);
			frameAComplex[i].Update((double)frameL[i] + (double)frameR[i], 0.0);
		}

		// 对一帧FFT，结果是每帧的频谱（间隔20ms）

		Complex spectL[4096];
		Complex spectR[4096];
		Complex spectA[4096];

		FFT(frameLComplex, spectL, FrameLength);
		FFT(frameRComplex, spectR, FrameLength);
		FFT(frameAComplex, spectA, FrameLength);

		for(int i = 0; i < FrameLength; i++) {
			diffSumL += log10(spectL[i].AbsSqr());
			diffSumR += log10(spectR[i].AbsSqr());
			diffSumA += log10(spectA[i].AbsSqr());
		}
		diffSumL /= FrameLength;
		diffSumR /= FrameLength;
		diffSumA /= FrameLength;

		INL[beats].Update( diffSumL , 0.0);
		INR[beats].Update( diffSumR , 0.0);
		INA[beats].Update( diffSumA , 0.0);

		cout << "已处理 " << (int)((double)beats / (double)BeatsLength * 100.0) << "%   (" << beats << " / " << BeatsLength << ")" << endl;

		beats++;
		if( Wave.eof() || beats==BeatsLength )
		{
			if(Wave.eof())
			{
				cout<<"采样不足！"<<endl;
			}
			break;
		}
	}

	Wave.close();

	// 对声谱图作FFT
	FFT(INL, OUTL, BeatsLength);
	FFT(INR, OUTR, BeatsLength);
	FFT(INA, OUTA, BeatsLength);

	double maxL = 0;
	int maxIndexL = 0;

	double maxR = 0;
	int maxIndexR = 0;

	double maxA = 0;
	int maxIndexA = 0;

	// BPM 30-300
	int indexLower = (int) (( 30.0 * (double)BeatsLength ) / ( (double)SampleRate * 60.0 / (double)FrameLength ));
	int indexUpper = (int) (( 300.0 * (double)BeatsLength ) / ( (double)SampleRate * 60.0 / (double)FrameLength ));
	for(int i = indexLower; i < indexUpper; i+=1)
	{
		cout<<"节奏谱L "<<i<<" ... "<<log10(OUTL[i].AbsSqr())<<endl;
		cout<<"节奏谱R "<<i<<" ... "<<log10(OUTR[i].AbsSqr())<<endl;
		cout<<"节奏谱A "<<i<<" ... "<<log10(OUTA[i].AbsSqr())<<endl;
		if(log10(OUTL[i].AbsSqr()) > maxL && i > 0)
		{
			maxL = log10(OUTL[i].AbsSqr());
			maxIndexL = i;
		}
		if(log10(OUTR[i].AbsSqr()) > maxR && i > 0)
		{
			maxR = log10(OUTR[i].AbsSqr());
			maxIndexR = i;
		}
		if(log10(OUTA[i].AbsSqr()) > maxA && i > 0) {
			maxA = log10(OUTA[i].AbsSqr());
			maxIndexA = i;
		}
	}

	cout<<"节奏谱峰值 XL["<<maxIndexL<<"] : "<<maxL<<endl;
	cout<<"节奏谱峰值 XR["<<maxIndexR<<"] : "<<maxR<<endl;
	cout<<"节奏谱峰值 XA["<<maxIndexA<<"] : "<<maxA<<endl;

	double BPML = ( (double)maxIndexL * (double)SampleRate * 60.0 ) / ( (double)FrameLength * (double)BeatsLength );
	double BPMR = ( (double)maxIndexR * (double)SampleRate * 60.0 ) / ( (double)FrameLength * (double)BeatsLength );
	double BPMA = ( (double)maxIndexA * (double)SampleRate * 60.0 ) / ( (double)FrameLength * (double)BeatsLength );

	cout<<"左声道BPM： "<<BPML<<endl;
	cout<<"右声道BPM： "<<BPMR<<endl;
	cout<<"平均声道BPM： "<<BPMA<<endl<<endl;

	cout<<"  平均BPM： "<<(BPML + BPMR) / 2.0<<endl;
	cout<<" 也可能是： "<<(BPML + BPMR) / 4.0<<endl;
	cout<<" 也可能是： "<<(BPML + BPMR) / 8.0<<endl;
	cout<<" 也可能是： "<<(BPML + BPMR) / 2.0 * 2.0<<endl;
	cout<<" 也可能是： "<<(BPML + BPMR) / 2.0 * 4.0<<endl;

	return 0;
}
```


#!style

canvas {
    display: block;
    border: 1px solid #aaaaaa;
    margin: 10px auto 10px auto;
}
#!script

#!script:./script/signal.js

// 将实数序列转换为复数序列
Array.prototype.toComplexList = function() {
    let list = this;
    let clist = new Array();
    let normLen = (LOG[list.length] === undefined) ? parseInt(Math.pow(2, parseInt(Math.log2(list.length) + 1))) : list.length;
    for(let i = 0; i < normLen; i++) {
        if(list[i] !== undefined) {
            clist.push(new Complex(list[i], 0));
        }
        else {
            clist.push(new Complex(0, 0));
        }
    }
    return clist;
};

function clear(canvas) {
    canvas.height = canvas.height;
}

function adaptRatio(context) {
    var devicePixelRatio = window.devicePixelRatio || 1;
    var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return devicePixelRatio / backingStoreRatio;
}

function canvasInit(canvas) {
    let context = canvas.getContext('2d');
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    canvas.width = WIDTH * adaptRatio(context);
    canvas.height = HEIGHT * adaptRatio(context);
}

// 将[0~SIZE)序列做周期延拓，然后取[-0.5SIZE~0.5SIZE)
function reverse(seq, size) {
    let newSeq = new Array();
    for(let i = 0; i < size / 2; i++) {
        newSeq[i] = seq[i + size / 2];
    }
    for(let i = size / 2; i < size; i++) {
        newSeq[i] = seq[i - size / 2];
    }
    return newSeq;
}

// 输入Wave中的波形[0~SIZE)
// 输出频谱实部[-pi~pi)
function RealFFT(input, SIZE) {
    let IN = input.toComplexList();
    let OUT = FFT(IN, IN.length);
    // 取实部
    let outRe = new Array();
    for(let i = 0; i < OUT.length; i++) {
        // outRe.push(Math.log(Math.abs(OUT[i].rep)));
        // outRe[i] = Math.sqrt(OUT[i].imp * OUT[i].imp + OUT[i].rep * OUT[i].rep);
        outRe[i] = OUT[i].rep;
    }
    // 平移到[-pi~pi)
    // return reverse(outRe, SIZE);
    return outRe;
}
function RealIFFT(input, SIZE) {
    let IN = input.toComplexList();
    let OUT = IFFT(IN, IN.length);
    // 取实部
    let outRe = new Array();
    for(let i = 0; i < OUT.length; i++) {
        outRe[i] = OUT[i].rep;
    }
    return outRe;
}

$(function() {
    // 覆盖原来的plot
    function plot(xs, ys, canvas) {
        let context = canvas.getContext('2d');

        const SHIFT  = 10;
        var XMIN   = Math.min.apply(null, xs) - SHIFT;
        var XMAX   = Math.max.apply(null, xs) + SHIFT;
        var YMIN   = Math.min.apply(null, ys) - SHIFT;
        var YMAX   = Math.max.apply(null, ys) + SHIFT;
        var XRANGE = XMAX - XMIN;
        var YRANGE = YMAX - YMIN;

        const toCanvasX = function(x) {
            return (x-XMIN) * canvas.width / XRANGE;
        };
        const toCanvasY = function(y) {
            return (YMAX-y) * canvas.height / YRANGE;
        };

        // background
        context.fillStyle = '#000000';
        context.fillRect(0, 0, canvas.width, canvas.height);

        // axis
        context.strokeStyle = '#555555';
        context.beginPath();
        context.moveTo(toCanvasX(XMIN), toCanvasY(0));
        context.lineTo(toCanvasX(XMAX), toCanvasY(0));
        context.stroke();
        context.beginPath();
        context.moveTo(toCanvasX(0), toCanvasY(YMIN));
        context.lineTo(toCanvasX(0), toCanvasY(YMAX));
        context.stroke();

        // number
        context.font = '13px Arial';
        context.fillStyle = '#aaaaaa';
        context.fillText((Math.round((YMAX-SHIFT) * 1000) / 1000).toString(), toCanvasX(0)+5, toCanvasY(YMAX)+12);
        context.fillText((Math.round((YMIN+SHIFT) * 1000) / 1000).toString(), toCanvasX(0)+5, toCanvasY(YMIN)-8);
        context.fillText((Math.round((XMIN-SHIFT) * 1000) / 1000).toString(), toCanvasX(XMIN), toCanvasY(0)-5);
        context.fillText((Math.round((XMAX+SHIFT) * 1000) / 1000).toString(), toCanvasX(XMAX)-50, toCanvasY(0)-5);

        context.strokeStyle = '#00bb66';
        context.beginPath();
        context.moveTo(toCanvasX(xs[0]), toCanvasY(ys[0]));
        for(let i = 0; i < xs.length; i++) {
            // context.beginPath();
            // context.moveTo(toCanvasX(xs[i]), toCanvasY(0));
            context.lineTo(toCanvasX(xs[i]), toCanvasY(ys[i]));
            // context.stroke();

            // context.fillRect(toCanvasX(xs[i]), toCanvasY(ys[i]), 1, 1);
        }
        context.stroke();
    }

    // 自相关序列
    function autocorrelation(seq, length) {
        let res = new Array();
        function getValue(seq, i) {
            return (i >= seq.length || i < 0) ? 0 : seq[i];
        }
        for(let i = 0; i < length; i++) {
            let sum = 0;
            for(let t = 0; t < length; t++) {
                sum += getValue(seq, t) * getValue(seq, t-i);
            }
            res[i] = sum;
        }
        return res;
    }

    const timeCanvas = document.getElementById('time');
    const freqCanvas = document.getElementById('freq');

    canvasInit(timeCanvas);
    canvasInit(freqCanvas);

    const SIZE = 1024;

    let timer = 0;

    let x0 = new Array(SIZE);
    for(let i = 0; i < SIZE; i++) {
        x0[i] = i;
    }
    let xhalf = new Array(SIZE/2);
    for(let i = 0; i < SIZE/2; i++) {
        xhalf[i] = i;
    }

    // 黑翼之心2048帧能量采样。只用前1024帧的采样，约23.7s
    const kurotsubasa = [77.1794,67.0529,73.9092,61.1696,60.7106,71.8365,76.5819,77.103,66.0907,66.9557,52.1107,86.4213,90.9428,85.9807,78.5929,76.599,78.615,72.2614,71.8778,65.2399,67.0123,80.8867,66.3186,55.811,82.3933,83.0112,80.6829,76.5832,67.0698,57.5557,78.076,80.3537,77.7161,75.7201,57.2362,56.2738,68.62,84.1496,83.9973,77.3087,83.1508,86.4183,78.6366,76.5575,78.6075,72.9273,73.246,69.4275,64.1978,78.3207,89.0464,80.2622,85.1788,79.9625,70.4315,67.026,66.3548,76.2672,70.0193,63.7457,65.912,74.3499,63.7611,88.016,86.838,85.2683,88.6818,89.0817,82.4102,76.6495,81.6826,61.6919,76.5757,78.9567,61.3975,67.5318,88.539,87.9832,80.8012,74.4457,82.8235,60.0718,56.8133,69.7751,76.1325,61.5626,64.2823,59.8934,68.7635,85.5778,81.4108,76.698,77.9869,82.2743,75.4312,69.0938,81.8426,80.4918,63.1779,58.9795,72.116,69.3054,84.3527,81.7422,70.7272,71.895,82.8891,80.4376,61.2273,67.0152,56.3747,65.0683,55.0459,59.0436,76.8742,87.6379,83.7059,76.8353,71.6273,67.5036,67.4382,70.4496,66.4682,67.8627,60.3109,54.7564,65.2421,69.4004,80.1857,73.5877,75.0078,83.3758,78.7477,76.0305,70.4358,70.26,60.2183,66.3919,65.7473,61.7172,80.11,83.6801,83.2627,84.3339,69.6188,70.7279,66.8889,69.4917,68.3479,69.0241,76.6755,68.4813,70.2683,82.4202,85.7416,84.5214,71.8111,77.5184,72.7459,82.238,77.7882,85.5943,83.5843,72.5122,69.5292,79.6557,86.8792,86.2081,84.6144,80.0449,80.8416,76.3979,75.337,78.9731,72.0538,82.5749,77.2681,76.3316,69.7808,84.331,79.5865,74.2932,70.4781,65.233,66.8152,68.2375,78.5155,77.0811,72.2442,81.1273,64.9952,78.253,84.7862,82.0603,83.1466,70.346,79.5816,81.8169,82.9224,72.7155,67.086,60.2759,59.2773,70.5598,79.6082,85.9076,78.2517,72.2408,78.2333,63.7984,79.0748,75.1468,64.685,61.1982,66.9945,65.2053,68.8235,62.7094,85.9839,86.7976,79.5595,72.2257,68.5844,78.1321,67.3287,66.6761,71.3367,63.6221,73.0029,65.0885,63.7477,79.7488,77.8787,78.6755,76.0435,69.4954,60.6651,88.7573,77.7046,60.328,70.7315,82.4666,69.845,63.91,84.1403,82.0074,78.7168,77.3005,73.134,80.0248,67.5616,70.622,82.5047,65.568,64.6421,67.2666,63.2265,86.9933,76.1917,66.2801,74.0679,77.6877,78.977,71.2046,82.9286,81.2758,70.5519,81.1518,67.7995,82.8699,92.4494,89.5569,78.0187,72.0341,78.4544,77.1885,67.0687,68.8685,74.5117,71.8499,65.7706,68.2303,83.7184,88.0592,78.4923,64.837,65.1948,75.8341,67.0288,70.7421,78.4333,66.1298,67.5132,66.2722,65.0181,76.5111,85.2017,79.6217,84.8517,87.5018,79.1344,79.9636,69.6873,87.0625,73.7645,67.6386,66.7138,60.6734,88.0249,86.6975,81.0939,71.1541,70.8802,86.921,66.0503,77.265,68.0433,76.445,84.0264,70.5492,79.1088,87.2404,88.7911,86.8623,84.2556,81.4218,73.6728,72.5336,70.3319,77.7079,84.7055,78.75,70.1384,66.6472,80.8753,76.6671,74.8597,69.9686,84.1709,76.2682,71.6434,69.7971,67.4085,77.1574,73.1474,62.378,65.2726,81.7074,89.2115,82.8574,75.3139,70.1563,78.1261,69.0535,73.2936,72.3018,73.3096,64.218,72.9248,74.4184,84.6617,83.8593,72.2671,69.2689,67.9985,72.0646,75.3246,79.2196,80.5857,74.9361,62.3292,70.126,76.5803,91.6614,88.3416,77.371,78.617,86.4811,82.4536,70.9369,70.0747,72.5037,77.3247,82.7638,73.3596,79.1495,87.8011,76.6741,70.1537,66.1588,82.9097,65.3314,70.9656,71.7759,65.7609,58.3742,62.894,71.7476,79.0807,83.0815,81.8428,74.1746,69.5104,77.0246,77.1522,66.258,73.3154,77.2182,62.1856,50.5827,74.3304,72.4186,85.5354,76.6546,74.2491,81.7955,79.2397,70.7758,72.7705,73.982,75.6931,65.1729,61.3669,67.8593,82.2936,88.3186,85.5922,77.6543,79.5854,76.7599,75.804,82.076,74.3768,73.1996,77.9676,75.5155,60.6021,70.1613,86.4178,82.0801,72.1319,65.6046,78.7077,83.3962,78.6853,65.4902,59.2985,77.0882,73.028,57.0778,77.6545,83.397,81.608,75.2586,74.3593,71.7753,76.5451,82.2563,84.8878,80.7349,75.1148,62.2545,76.3717,78.3824,88.8951,86.4839,73.6955,67.3015,75.6953,73.1889,80.1508,75.8274,82.4715,77.9092,65.1466,69.3815,84.2319,86.2087,80.9397,76.4515,75.658,77.5521,74.6575,70.4785,67.5678,65.2968,62.4543,65.1197,74.6526,83.2428,81.9744,76.8634,66.49,78.5365,72.9276,69.9581,76.3993,69.702,58.7651,65.7658,65.3027,57.3198,84.1428,83.3269,84.8042,73.2153,87.2646,86.5837,80.0584,74.6768,79.197,70.7253,78.0013,79.723,75.1784,84.5661,82.8648,84.5653,82.8975,69.8501,72.0121,78.3575,75.243,75.1413,73.0371,74.2547,71.3375,78.0642,87.7643,87.3406,80.8562,79.3194,72.0783,74.5025,74.9094,70.6714,66.4014,65.7445,71.3525,76.3723,68.844,78.2021,79.1364,72.733,66.9505,71.231,74.2198,66.7835,70.1447,69.9628,72.5095,71.6105,67.1318,67.9227,87.1485,86.0261,75.0885,73.5786,72.8101,65.6692,86.51,82.5133,79.4341,70.8777,71.8609,65.0872,83.1077,92.1977,83.4559,79.4656,80.0151,70.4013,76.3337,76.1608,77.449,75.8572,75.7047,79.2735,74.5581,84.306,88.3279,86.0279,78.8523,76.4537,65.7502,70.1951,78.9844,85.4952,69.0597,73.1806,68.6595,64.5137,90.2821,95.5475,90.1159,81.7576,74.9717,67.1372,72.5367,84.3707,79.529,82.3983,80.6111,65.4666,68.8037,97.2336,96.6256,90.3219,89.7451,90.685,93.0617,88.2541,88.4005,89.4443,87.8428,84.1319,84.125,84.4967,88.231,92.3537,88.409,84.3407,91.5437,86.8385,81.6434,81.2805,81.1331,77.3468,75.9468,75.4257,77.7234,90.2134,93.9659,86.9883,79.8857,77.1013,79.1392,73.1094,73.0843,71.0764,70.6909,70.8199,70.1487,69.8976,83.5145,83.2705,91.9287,91.8155,81.1684,75.3552,84.8506,77.4913,64.5295,67.0898,63.6976,69.5326,62.2553,102.298,89.476,84.2627,88.1438,85.4952,78.9145,78.5958,78.0707,76.726,76.6985,77.8489,73.2654,73.2386,87.5407,85.7035,75.8896,72.2652,69.7369,70.2866,69.2802,82.7168,74.9229,72.011,68.8095,64.0106,71.9346,85.368,86.2905,77.4793,72.2539,65.2636,61.7418,68.9114,73.7003,70.9767,68.9525,73.4296,69.7439,62.8701,89.1755,81.1215,71.8722,68.3073,64.231,77.1913,82.6259,84.5338,77.0968,79.2002,79.9696,74.2874,81.1152,94.5419,83.4747,76.5413,74.2926,74.7074,79.2919,71.9829,68.3682,66.4408,74.9269,67.7047,68.3216,70.6525,89.1839,84.1469,75.5229,66.5057,81.2898,81.6485,69.9841,67.1228,63.7725,63.0564,68.8351,63.3408,79.0092,88.9381,87.6524,79.6547,72.561,71.2178,67.1178,63.7489,64.3354,62.8911,58.8859,60.7402,73.0486,67.4347,83.4115,83.9989,85.2992,81.4981,72.1909,70.6933,65.3068,62.699,68.1339,60.2086,77.2795,75.5503,100.885,90.5409,84.4346,86.8996,77.7487,77.5415,78.3897,78.9285,73.8448,77.8287,78.0921,71.5363,75.0202,81.2774,87.3657,80.3079,71.379,77.9411,66.6347,64.7648,73.5885,75.8529,74.133,76.9181,69.7828,61.805,85.216,85.3709,80.7101,75.7533,74.1915,78.4991,62.8289,65.1109,64.2306,56.551,59.4051,62.468,56.5172,84.216,88.7943,81.6645,71.5956,73.0582,79.4603,65.1755,77.8759,82.2837,68.8993,78.2582,67.3177,72.4918,87.4411,85.6092,79.0908,80.1165,85.9304,77.0303,67.3448,65.9219,67.3187,64.3879,59.6964,59.0809,65.8136,87.9543,85.4615,77.9844,78.9228,85.7166,72.05,71.3801,70.4282,77.0164,75.4709,66.1738,68.9533,63.0051,90.3044,87.8629,83.5678,72.9418,80.6234,78.9792,71.5918,74.5402,76.2225,76.0936,74.5883,80.773,73.5451,81.0708,79.2481,73.338,69.8619,74.6388,79.5618,77.5822,74.1568,68.5209,78.6114,74.2233,67.3795,67.7116,85.8465,86.5815,81.541,76.4543,83.8528,79.3472,65.9187,64.4982,69.0574,63.7287,59.0015,61.6583,59.4598,102.507,82.5434,81.0755,75.9156,79.7076,79.3747,72.5406,81.6877,75.8639,73.1522,76.3147,69.8293,78.3103,89.6543,86.5843,83.88,74.984,64.9502,73.9745,65.1526,82.0138,72.1044,63.3484,68.6736,59.1666,78.9913,91.45,81.2992,78.0998,79.6528,64.7016,61.045,79.6135,73.6901,73.4641,64.2009,68.9543,73.3273,94.095,97.9079,89.2535,81.5546,74.2546,73.356,70.4461,73.571,71.2284,69.2028,71.4833,68.1373,73.285,79.6661,84.701,77.2264,71.4661,79.2081,76.1782,69.2693,67.7958,64.7095,62.2919,59.2965,58.7692,69.7666,86.3211,89.5901,87.9514,86.399,69.4342,62.5429,73.121,81.0308,78.4986,72.983,64.4945,68.9892,63.8953,83.0896,84.949,76.2979,73.0481,66.2531,64.4151,69.0959,73.8396,66.8253,73.7881,63.5104,62.6363,57.9271,91.9635,89.194,86.1918,79.0383,81.0012,79.7958,76.1004,70.923,72.3443,71.4511,70.4105,66.0252,66.5825,84.3812,82.7862,77.0396,76.9107,71.2376,72.0891,72.5738,79.176,76.9966,76.6802,69.3335,70.0506,72.0475,88.9415,84.7618,85.0668,84.8265,83.4974,77.2671,65.9584,61.281,58.8912,69.0939,65.8564,57.0082,67.0367,90.9817,86.2812,72.5793,77.7422,67.7498,71.8854,73.562,77.887,74.5993,67.7828,73.349,69.779,67.3502,101.118,84.1876,82.8988,79.2224,73.2842,73.275,74.1502,75.5402,70.1324,73.0105,72.4869,70.3192,71.1558,90.7629,89.098,84.2428,72.2979,84.6241,81.8494,69.7064,76.4361,64.696,62.892,66.0609,68.0229,63.058,90.8204,87.3022,78.4639,77.8854,79.8983,78.4845,65.8386,71.7231,69.8476,69.492,69.0382,76.0497,79.2112,85.5773,79.4571,80.1587,71.0468,71.6099,70.2752,69.3186,78.5545,66.4781,76.2351,77.3041,71.1525,98.0216,99.3852,84.864,83.8889,89.5978,79.873,79.1087,78.7548,76.6825,77.0838,76.7655,75.1663,72.1411,77.7659,87.5501,81.126,80.3656,82.6868,85.0359,79.4337,70.6873,76.8499,71.3049,69.9051,72.3914,72.2367,82.356,85.5651,87.9202,82.7466,71.0259,66.1739,62.8182,71.0455,66.4854,68.5873,60.25,68.2678,65.5241,86.1721,83.5382,76.3221,70.1368,76.4291,66.0056,74.9052,79.1129,82.9273,74.0246,64.7875,68.4653,74.2954,95.1868,91.3715,79.3771,77.3236,76.5586,70.2379,69.7669,74.8625,66.9146,67.4293,67.272,69.5162,74.0202,88.457,83.1456,77.3186,67.721,75.7472,80.5104,77.7059,63.0107,69.7916,74.4829,61.3873,64.5989,70.9306,87.8133,87.2276,82.0123,77.9138,67.6872,70.4483,62.9227,78.1034,66.0764,72.3894,71.2791,59.9573,60.7642,81.2066,78.9887,75.844,77.6053,82.3874,83.5553,81.971,74.9,69.2907,63.4232,66.8932,60.692,71.1406,103.899,84.7492,83.1898,81.554,80.6041,78.0998,77.9867,79.2878,78.0227,74.3148,72.0064,72.6738,74.7337,91.3011,83.1247,73.7952,75.5419,82.3104,75.2577,63.6407,80.6021,80.842,76.4861,78.4675,77.1351,62.8604,87.2808,85.5623,77.1742,68.5598,65.9464,75.9863,64.9034,58.2375,65.151,66.5426,55.6263,55.6399,73.1605,90.0634,82.6264,73.6292,73.3595,68.1137,71.8438,75.5371,81.985,75.733,74.9339,76.6694,66.5369,84.2522,90.2016,80.6559,81.1968,79.3165,66.762,71.9457,68.383,71.415,64.9635,69.1555,64.0369,64.1333,74.6586,87.9133,82.1065,72.8371,64.6652,86.0806,82.7939,75.636,65.4623,60.3781,62.8343,67.2899,58.5275,81.8231,91.0015,85.5089,79.234,73.6852,74.124,76.0849,76.6714,68.8508,76.7724,70.6029,63.6206,70.0959,81.3438,87.4978,77.9461,73.5977,70.5947,63.8615,72.8757,82.3031,75.1987,66.9626,78.3625,67.2225,65.3036,84.1573,86.8596,81.0708,77.4962,69.9417,69.9997,68.8802,64.1888,68.6605,60.5807,65.9238,62.0873,70.1625,100.506,86.9235,85.539,80.7563,80.7019,81.2339,75.1306,84.4409,90.9808,82.642,74.3701,80.0836,77.076,88.555,86.9722,78.9162,76.6481,67.1583,66.8821,76.3421,76.814,65.4458,62.0136,67.0472,66.187,59.2877,87.4362,85.4512,72.3196,89.2822,84.9982,64.6556,81.203,82.9311,81.4165,75.6805,63.6568,64.9038,59.8785,86.1448,85.7478,79.8333,75.6169,70.7968,70.3898,75.1381,81.3883,71.475,62.4338,63.0535,61.0158,64.2182,86.7322,79.3475,84.0449,72.386,88.8952,80.1138,68.7134,70.4521,68.7061,63.2028,72.9566,58.1556,55.4617,91.5755,97.1409,82.7662,84.2124,70.4953,70.5301,67.9633,67.4823,75.3106,75.5814,66.1723,62.0026,70.0688,86.1386,78.7802,73.2225,70.7512,76.9113,70.232,69.2127,68.935,75.0505,61.249,58.4277,56.5873,90.1108,93.1163,87.5091,85.309,79.2404,81.2528,78.3988,87.8175,83.0553,78.8178,73.6752,72.7195,68.807,89.706,93.5791,83.5329,78.1823,73.9945,76.39,76.8989,78.7428,79.7675,81.6277,83.1071,73.5885,73.4668,87.8187,92.3435,86.6069,80.5008,73.9691,77.4663,76.7082,78.1899,70.6642,77.1793,83.6948,82.7575,79.223,90.2285,88.2395,82.5637,84.1445,70.4416,63.6133,61.948,90.3339,83.0532,81.6668,78.7408,75.8761,77.3581,86.7915,91.217,90.7805,88.2353,89.2856,90.0285,86.4427,85.9283,86.8267,85.9342,84.0247,84.1097,82.4806,88.3728,89.0848,84.1216,82.5134,81.3471,84.9702,78.7485,77.5437,76.7802,76.3485,77.4423,74.763,74.4398,86.3406,91.0538,83.8152,79.4336,74.8898,73.711,71.5159,72.6551,78.5211,75.7968,71.6931,69.9013,69.3978,78.5604,78.8303,79.4556,70.4814,68.0729,71.8121,73.7521,69.1988,66.7354,72.9816,72.7982,65.1714,71.6634,88.2914,84.761,85.395,78.8556,73.0858,73.9953,72.4374,76.3349,69.1451,69.7874,64.6692,65.4547,67.7946,85.6561,79.0367,72.8741,72.3722,76.7286,71.8432,78.5939,81.0312,82.5178,71.159,68.6095,80.6475,69.6321,90.0152,87.9438,82.1971,81.5651,73.73,66.4929,74.9953,74.2798,68.7304,76.2277,70.5112,69.0112,77.021,86.0644,80.4957,76.259,71.8323,71.4782,77.1597,64.2346,70.8717,64.7055,67.4937,58.873,56.8909,72.5175,91.8298,80.9753,81.0926,68.6,83.7628,85.803,68.2449,65.1205,79.2552,67.076,72.7733,62.962,75.9284,84.2299,81.9337,81.6207,75.5871,65.3528,67.1487,74.1962,77.7508,68.5196,75.9634,75.5055,68.558,81.6911,90.4038,84.105,76.6159,75.6715,73.2096,69.8596,64.1899,64.0044,70.7426,64.2795,63.052,64.8887,73.2872,78.9964,76.722,76.5556,72.1436,77.5066,71.8467,65.3225,65.7168,72.3651,72.8123,73.8924,81.083,77.3036,84.3584,87.9788,78.2678,67.9957,73.1194,74.4505,75.5285,64.0112,76.6565,66.6438,70.9786,61.1312,79.3719,84.2656,80.4977,70.5672,80.8075,77.5059,77.0819,79.4517,81.155,77.5596,69.1771,77.3388,60.191,84.3384,86.1909,81.16,76.2785,69.2306,64.2643,61.4829,59.3058,60.4611,67.5191,61.9596,60.7055,75.8351,91.386,84.8425,76.886,71.7933,61.1513,67.6688,73.5874,70.7378,69.4665,72.4766,73.6363,66.2149,67.2278,86.2363,85.0615,90.681,79.0491,81.1718,82.6594,68.8887,66.823,62.4842,69.9648,67.31,63.8691,65.3197,84.6949,80.1259,72.6635,70.0457,64.8809,76.8569,73.3831,67.4447,66.9598,68.7094,69.5231,74.0356,67.9484,89.8705,91.7438,79.7822,71.7768,67.3996,73.4398,79.6668,80.4374,75.8837,68.937,65.7325,64.8734,66.7272,80.3011,82.464,71.8301,70.2859,67.0108,63.8918,83.0555,87.53,78.1945,71.2034,66.4336,67.0775,76.1776,89.6614,82.2224,77.7592,71.8691,78.1035,71.3917,76.1696,70.8656,64.8011,64.1121,66.6517,74.0216,67.3116,89.8268,76.3331,71.3073,72.8689,74.9839,72.4723,72.668,81.9194,75.8207,70.7505,69.4574,65.9041,88.6328,93.6175,86.9611,77.0768,71.1229,70.7422,65.1766,68.5731,78.8274,76.1763,71.9696,74.2437,70.3181,80.3871,89.177,75.6372,75.5782,67.6217,78.1812,72.4732,68.0406,70.7624,59.5739,61.0231,59.5178,59.7099,76.6706,86.487,78.4797,87.2817,84.487,76.6113,68.1349,66.2042,66.6292,66.8254,66.7502,73.8833,70.173,77.7516,86.7184,82.6412,72.2468,66.0427,68.912,64.5229,69.8859,81.9347,76.3541,78.1953,81.9304,79.2779,85.5282,87.3266,82.2058,75.35,72.5411,72.3821,68.8478,66.5657,66.5879,73.0128,76.9914,70.2797,73.8704,75.0261,84.1507,84.3618,74.1329,74.3623,68.1865,71.954,73.4155,64.5466,82.4011,79.4047,79.3526,86.0233,86.2457,84.8931,79.8793,75.4984,69.2636,68.2331,76.9534,76.3938,66.0626,67.6854,69.7707,71.2849,69.6248,87.2771,84.6643,73.7265,76.7015,70.5293,82.6928,73.4798,84.1272,81.5302,74.1746,70.6144,66.4538,74.8761,89.0517,89.1997,82.1237,77.1028,68.7773,77.8861,72.8496,60.0181,60.8271,72.7928,79.2081,70.4173,66.2255,83.1929,75.5142,74.8571,75.6729,71.1019,65.6979,74.3726,77.4912,73.4087,74.4208,67.7853,73.141,72.276,91.5728,90.0993,90.0109,87.6357,88.9002,86.908,86.8887,86.3447,87.7044,85.1391,83.3029,84.627,86.0569,88.7649,84.7977,83.1662,83.9481,81.9691,79.3642,77.4227,77.3053,75.5534,75.7558,77.5628,74.6139,80.5548,92.8333,90.8637,86.0045,80.0181,77.4811,78.1689,78.0448,71.6507,72.3064,70.1626,70.5258,73.4305,72.3172,82.33,80.4103,70.7431,69.4521,72.3332,75.3954,70.8481,78.382,80.9635,68.7006,67.2108,73.3326,82.0095,86.2457,82.6353,82.5852,72.4648,71.6132,76.4744,74.0899,68.9554,65.9898,64.4636,65.1673,65.2431,78.1873,85.7869,73.8167,74.4757,67.5344,71.0054,66.626,76.6765,87.4142,76.3936,69.093,70.2681,71.7135,87.5474,88.3874,83.6731,75.1985,73.7561,83.5175,76.1748,74.5921,67.5836,67.8204,65.1908,63.956,65.3416,81.3181,83.9609,84.5228,75.1517,69.4379,79.2594,78.9664,69.3537,74.2993,57.8509,64.2281,57.3959,46.2889,81.5606,83.5576,79.8564,77.3845,85.7554,83.7618,74.1089,75.0016,66.8066,76.8035,81.6208,76.8081,64.6964,84.6472,88.2407,74.0913,82.0818,80.0165,65.1372,67.1454,68.9852,70.6982,67.6108,70.7834,72.3156,68.8237,86.8638,88.1329,78.1773,82.5823,75.3834,65.6944,69.6894,63.6671,66.926,71.1233,68.0077,64.5766,68.1727,82.8225,83.5478,77.7178,79.5714,66.1691,67.4841,71.0249,76.9578,76.8894,73.8216,73.9003,75.2498,68.621,84.3228,82.9397,80.2754,79.9734,78.1062,63.8665,73.2008,79.216,64.4113,63.9574,72.7105,67.724,65.0169,89.593,81.2706,70.5769,66.5194,67.9668,72.8648,66.5178,79.679,74.3138,73.1696,65.6763,60.7051,79.2549,89.6125,82.6355,73.5863,74.191,73.4491,61.805,61.7755,69.7886,75.4344,62.2941,60.6914,61.7987,73.9687,84.4999,78.042,77.1011,73.0057,74.7542,61.353,77.9298,76.1764];

    $('#bpm').click(function() {
        let input = new Array(SIZE);
        for(let i = 0; i < SIZE; i++) {
            input[i] = kurotsubasa[i];
        }
        // 滤除源信号的直流分量
        let outRep = RealFFT(input, SIZE);
        outRep[0] = 0;
        let noDC = RealIFFT(outRep, SIZE);

        // 求自相关序列
        let acseq = autocorrelation(noDC, SIZE);
        // 求自相关序列的频谱
        let acspect = RealFFT(acseq, SIZE);
        // 求BPM
        let maxv = 0;
        let maxi = 0;
        for(let index = 0; index < acspect.length / 2; index++) {
            if(acspect[index] >= maxv) {
                maxv = acspect[index];
                maxi = index;
            }
        }
        let BPM = Math.round(1292 * maxi / (acspect.length / 2 - 1));

        plot(x0, acseq, timeCanvas);
        plot(xhalf, acspect, freqCanvas);

        $('#bpm').html(`BPM = <strong>${BPM}</strong>`);
    });
});