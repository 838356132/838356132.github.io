
#!title:    我想给你整个世界
#!date:     2017-09-30
#!authors:  Mikukonai
#!cover:    
#!type:     原创
#!tags:     函数式编程,计算机科学

#!content

> 摘要：本文从λ演算和丘奇编码出发，从无到有地构造出加减乘除、递归、乃至简单的解释器，展示了λ演算作为一种抽象计算模型的强大能力。

# λ演算简介

------

**λ演算**是美国逻辑学家Alonzo Church为研究判定性问题而发明的一套符号演算体系。它的基本元素称为“项”（term），分为三种：

- **符号**：任何有效的名字
- **函数**：(**lambda** (%%symbol%%...) %%term%%)
- **调用**：(%%term%%...)

在本文中，我们采用Scheme的语法表示λ演算。以下几个表达式都是合法的λ表达式：

```:lisp
1 (a b)
2 (a (lambda (x) x)) ;函数作为参数
3 (lambda (x) x)     ;符号作为返回值
4 (lambda (x) (lambda (y) x) )    ;函数作为返回值
5 ((lambda (x) (lambda (y) x)) 2) ;调用
```

可见，在λ演算中，函数不仅可以被调用，还可以当作值传递。

在λ演算中，新的符号在函数的参数列表中定义，这样的符号可以称为“变量”，因为通过后面所讲的演算规则，它可以被其他项替换掉。变量的“**作用域**”就是它所在函数的函数体。由于函数体内还可以嵌套其他函数，因此在内层函数中定义的变量，会覆盖上级函数定义的同名变量。根据定义所在的函数层级，变量分为两种：

- **自由变量**指在函数体中出现，但是没有在本级函数参数列表中出现的符号。
- **约束变量**指的是在函数体中出现，且在本级函数参数列表中出现的符号。

约束变量可以视为形式参数，而自由变量可以视为全局变量。

λ演算的符号变换规则只有简单的三条：

- **α-变换**：在不覆盖到同一作用域内部的自由变量的前提下，约束变量的名字可以任意替换。

```:lisp
(lambda (阿猫) [阿猫]) = (lambda (阿狗) [阿狗])
```

- **β-归约**：可以用λ项去调用一个函数，方法是将函数体内出现的所有有效的（没有被内层函数覆盖的）参数约束变量都替换成λ项。

```:lisp
[(lambda (x) T) 喵] => T[x→喵]
```

箭头符号`=>`代表λ项在β-归约前后的变化。β-归约描述的这个符号变换过程，也可以称为“调用”（apply/call/invoke）。

- **η-变换**：可以对任何λ项进行抽象/封装。

```:lisp
f := (λ (x) (f x))
```

α-变换揭示了一个普遍的现象——形式参数的名称是不重要的。在某些语言中（例如JavaScript），不需要显式地声明函数列表，而直接用arg[n]代表第n个形式参数；在Java中，也常见arg0、arg1这样的说法。其背后的原理，就是α-变换。

β-归约是核心规则，它描述了“函数调用”的本质——约束变量代换。从操作语义的角度来看，β-归约所描述的“替换”过程，有许多值得讨论的技术细节。针对变量替换的顺序问题，有这样几种归约（求值）策略：

- 应用序求值：优先求值参数，以参数的最终值进行β-归约。从语法树的角度来看，可以看成是结果从叶子节点逐步汇集到根节点的过程。例如：

```:Scheme
((lambda (x y) (+ x y)) (* 3 3) (* 4 4))
((lambda (x y) (+ x y)) 9 16)
(+ 9 16)
25
```

应用序求值是绝大多数编程语言所采用的求值策略。**本文采用应用序求值，这也是Scheme的默认求值顺序。**

- 正则序求值：优先进行β-归约，将所有参数保留原形代入函数，消除所有函数定义后统一求值。从语法树的角度来看，可以看成是根节点逐步下移，语法树逐渐缩小成一个值的过程。例如：

```:Scheme
((lambda (x y) (+ x y)) (* 3 3) (* 4 4))
(+ (* 3 3) (* 4 4))
(+ 9 16)
25
```

- 按需调用（延迟求值/懒惰求值）：这种策略可以说是前述两种策略的一个折中，在不同的具体语言中有不同的操作语义。最为典型的就是Scheme的`if`原语，此结构并不会积极地求值每个参数，更不会把所有参数都推迟到完全展开后再计算，而是根据条件的真值，“选择”一项进行求值。这个“选择”显得非常玄幻，看起来像是超脱于λ演算的某种东西，实际上并没有那么玄幻，这里就是η-变换的用武之地了。我们将在后文中使用纯粹的λ演算构造出`if`原语。

此外，关于我们在本文中使用的λ演算，有两点说明：

+ 为了方便起见，我们引入了一个给λ项命名的手段：`(define 符号 λ项)`。有了`define`，就可以使用名字代替被命名的λ项，非常方便。但是，`define`并不是λ演算的一部分，严格地讲，它应该是我们在研究λ演算时所使用的“元语言”的一部分。在后文中，我们将会说明，`define`这个命名机制，实际上可以在λ演算中实现。因此，请放心使用吧。
+ λ演算中，所有的函数都只有一个参数。仍然是为了方便，我们会使用支持多个参数的λ演算。通过一种叫做**柯里化**（currying）的方法，可以把多参数的λ函数变换成多层单参数λ函数的嵌套。嵌套携带有层次顺序的信息，因此在多参数的函数中，参数列表中各个形式参数是有顺序的。**参数的顺序，实际上是一种隐含的数据结构。**

到这里，我们已经基本了解了λ演算的概貌，可以利用它来构造一个千变万化、恢弘精妙的虚拟世界了。


# 第一章：数和逻辑

---

## 自然数

我们采用Church提出的方法，从零开始逐渐构造自然数，直至无穷。

首先，定义数0如下：

```:Scheme
(define @0 (lambda (f a) a))
```

可以这样理解这个定义：`@0`作为一个函数，它接收两个参数，第一个参数`f`是一个函数，而第二个参数`a`是提供给`f`的参数。在`@0`的函数体中，并没有使用`a`去调用`f`，而是原封不动地直接返回。因此，我们可以说，`@0`是使用`a`调用`f`**零次**的结果。

基于这种理解，我们可以定义**后继函数**如下：

```:Scheme
(define INC
  (lambda (n)
    (lambda (f a)
      (f (n f a)))))
```

请注意，后继函数返回的是数字，即接收两个参数的函数。在函数体内部，`INC`用原来数字的结果又调用了一次`f`，并构造新数字返回，这就实现了“加一”的目的。

有了`@0`和后继函数，就可以产生出所有的自然数。例如：

```:Scheme
(define @1 (lambda (f a) (f a)))
(define @2 (lambda (f a) (f (f a))))
(define @3 (lambda (f a) (f (f (f a)))))
……
```

数字是用函数表示的，因此可以这样理解：表示数字的函数的内部调用`f`几次，这个函数就代表几。

## 布尔代数

布尔代数只有对立的两个值。如果把布尔值看成是一个道岔，那么两个布尔值分别指向不同的方向。因此，可以把布尔值定义成接收两个参数的函数，使其返回两个参数之一，这就构造出了布尔值。

```:Scheme
(define @true  (lambda (x y) x))
(define @false (lambda (x y) y))
```

看到了吗，`@false`的形式和`@0`的形式是完全一致的诶。在C语言等许多语言中，都有类似的以0（或者某个特殊值）指代false，而以其他任何值指代true的特性。

返回布尔值的函数称为“谓词”。现在来构造最简单的谓词`IS_ZERO`，思路是这样的：

首先谓词也是一个函数，它接收一个数字`n`作为参数。其次，数字`n`接收两个参数`f`和`a`。注意到在所有的自然数中，只有`@0`会原样返回`a`，因此，在`IS_ZERO`的函数体中，可以将`@true`作为`a`去调用`n`。`n`的参数`f`是一个函数，为了使所有的非`@0`数字调用这个函数都得到`@false`，只需要使`f`恒返回`@false`。至此，`IS_ZERO`就被构造出来了。它的形式是这样的：

```:Scheme
(define IS_ZERO
  (lambda (n)
    (n (lambda (x) @false) @true)))
```

这个过程暗示着，为了满足语义上的正确性，貌似需要对变量的“类型”加以限定。只有在参数中代入类型合适的λ项，才能得出有意义的结果。

判断结构是几乎所有的编程语言都有的结构。现在，有了两个布尔值，还有一个谓词，就可以尝试构造一个判断结构了。

最基本的判断结构接受一个条件和两个分支，条件的真值不同，执行的分支也不同。而刚刚构造的两个布尔值，本身就具有分支选择的功能，因此，我们可以把布尔值封装起来，这就是`IF`判断结构：

```:Scheme
(define IF (lambda (p x y) (p x y)))
```

可见，`IF`就是对布尔值使用η-变换后形成的封装。因为`IF`很好用，看起来甜甜哒，所以称它为布尔值函数的“语法糖”。

喜欢吃糖，总有一天要吃苦头的。

## 有序对

有序对，就是两个元素按照固定的顺序排列，形成的结构。

可以按照这样的方式构造一个有序对`PAIR`：有序对是一个函数，它返回一个函数。具体形式是这样的：

```:Scheme
(define PAIR
  (lambda (x y)
    (lambda (f)
      (f x y))))
```

首先，为什么`PAIR`要返回一个函数呢？因为从语义（运行时）的角度来讲，函数不仅仅是简单的字符串，而是一个保存了运行时上下文的数据结构。可以发现，`PAIR`将两个元素传入一个函数`(lambda (f) (f x y))`，并返回这个函数。刚刚传入的两个元素`x`和`y`很明显是这个函数的自由变量，为了在其他的地方使用这个被返回的函数时，不丢失生成它的上下文的信息（也就是`x`和`y`），它自己必须保存`x`和`y`的具体值（可以是立即值，也可以是引用，这与语言实现有关）。像这种，保存了包括自由变量的值在内的上下文环境的“函数”，称为“**闭包**”（closure）。因此，严格地说，**`PAIR`返回的是一个闭包**，一个包含了有序对的元素、及其位置信息的闭包。这个闭包不仅保存了信息，它还有行为——接收另外一个函数，去处理保存在闭包内部的元素。

其次，之所以这样构造`PAIR`，是因为这样可以充分利用两个布尔值的选择器作用。有了`PAIR`，有了布尔值，很容易写出分别提取`PAIR`中左右元素的函数：

```:Scheme
(define LEFT  (lambda (pair) (pair @true)))
(define RIGHT (lambda (pair) (pair @false)))
```

另外，上文中我们有说过，参数的顺序是一种隐含的数据结构。`PAIR`把两个参数**按顺序**放置在参数列表中，经柯里化就可以得到嵌套的两层λ函数。层次信息结合闭包特性，就是`PAIR`这个数据结构的λ演算本质。说到这一点，可以看一下SICP的习题1.3。简单来说，这个题要求找出三个数中最大的那个。常规思路是使用多个`if`对每种情况做判断，而使用λ函数的特点，可以写出这样的算法：

```:scheme
(define max
  (lambda (x y z)
    (if (and (>= x y) (>= x z))
        x
        (max y z x))))
```

这个算法充分利用了参数列表的“列表”特性，在递归中实现了列表的位移操作，简洁而机智。

有了自然数、布尔值和有序对，就可以继续建构更复杂的结构，描述更复杂的运算了。

# 第二章：运算

---

## 逻辑运算

布尔代数中，有与或非三个基本运算，这三个运算是完备的，因此我们首先构造这三个基本运算。

取反运算`NOT`很简单，它是一个接收1个布尔值作为参数的函数。

```:Scheme
(define NOT
  (lambda (bool)
    (bool @false @true)))
```

若两个真值之中有一个为`@false`，则得到`@false`，否则得到`@true`。这是`AND`。

与运算`AND`的特点是，如果两个布尔值里面有一个是`@false`，那么结果就是`@false`，否则得到`@true`。我们可以充分利用之前得到的经验，即将函数作为参数传入另一个函数，实现某种效果。因为`AND`接收两个布尔值，而布尔值有选择器的效果，我们不妨只关注第一个参数，并把它用作选择器，而另一个参数当作值，就像数字那样。当第一个参数取`@false`的时候，`AND`应当返回`@false`也就是第一个参数自身；当第一个参数取`@true`的时候，结果取决于第二个参数的值。因此，可以这样构造`AND`：

```:Scheme
(define AND
  (lambda (boolx booly)
    (boolx booly boolx)))
```

类似地，可以构造`OR`运算：

```:Scheme
(define OR
  (lambda (boolx booly)
    (boolx boolx booly)))
```

当然，构造方式并不是唯一的，只要能够满足类型约定和语义，就是正确的。

## 算术运算

首先从加法开始。加法，例如m+n，它的意义非常简单，就是给m（n）反复加一，重复n（m）次。因为上一章构造出来的数字有这种“重复n次”的意义，因此可以这样构造：

```:Scheme
(define ADD
  (lambda (m n)
    (m INC n)))
```

为了后文方便，这里先对`ADD`做柯里化：

```:Scheme
(define ADD-c
  (lambda (m)
    (lambda (n)
      (m INC n))))
```

有了加法，就可以构造出乘法，乃至乘方。这里就可以看出柯里化的意义所在了：柯里化的`ADD-c`，在只传入一部分参数（例如“2”）的时候，返回的是闭包，意义是“加2”。有的地方把这种特性称作“[部分调用](https://en.wikipedia.org/wiki/Partial_application)”。

```:Scheme
(define MUL
  (lambda (m n)
    (n (ADD-c m) @0)))

(define MUL-c
  (lambda (m)
    (lambda (n)
      (n (ADD-c m) @0))))

(define POW
  (lambda (m n)
    (n (MUL-c m) @1)))
```

减法要更难一点。因为加法是“重复”，是某种意义上的向前看，而减法则需要“回顾”，需要某种方法去“记忆”。

使用纯λ演算构造减法的方法同样不止一种，下面的这种方法是最容易理解的一种。

为了理解构造减法的思路，可以想象一个无穷数列，这个数列以`@0`为界，左侧是无穷多个`@0`，右侧是从`@0`开始的按后继顺序排列的自然数列。有一个宽度为2的滑动窗口，可以在这个数列上滑动，通过窗口，只能看到两个相邻的数字。

首先将滑动窗口初始化在最右侧的两个`@0`上，然后向右滑动n次，此时，窗口右侧的数字是n，而左侧的数字是(n-1)。只需要把窗口左侧的数字取出来，就可以获得(n-1)了，也就是n的前驱数。有了前驱数，就可以构造出减法了。

现在已经有了窗口，也就是`PAIR`，于是问题归结到，如何描述这个“滑动”的过程呢？

仍然是构造一个函数`SLIDE`，它接收一个旧窗口，将旧窗口右边的数放到新窗口的左边，然后将旧窗口右边的值后面的那个数（也就是后继数）放到新窗口的右边，返回新窗口。这样就实现了窗口向右滑动的效果。

```:Scheme
(define SLIDE
  (lambda (pair)
    (PAIR (RIGHT pair) (INC (RIGHT pair)))))
```

也可以理解成，窗口不动，数列向左走一步后，窗口里看到的两个数。

这样，就可以构造出前驱函数`DEC`和减法`SUB`了。

```:Scheme
(define DEC
  (lambda (n)
    (LEFT (n SLIDE (PAIR @0 @0)))))

(define SUB
  (lambda (m n)
    (n DEC m)))
```

需要注意的是，刚刚实现的减法并不是普通减法。因为，如果减数`n`比被减数`m`大，则窗口会滑动到左侧的`@0`的区域中，结果是`@0`，而不是负数（毕竟我们现在还没有构造负数）。这种减法叫做“[monus](https://en.wikipedia.org/wiki/Monus)”，符号是减号上面加个点。

有了减法，就可以比较大小。两个数`num1`和`num2`相减，若得到`@0`，说明**`num1`不比`num2`大**，或者说，`num1`小于等于`num2`。而`@0`是可以通过`IS_ZERO`判断的，所以就可以构造出谓词`IS_LE`，即“小于等于”。同样地，利用已有的逻辑运算，还可以构造出“大于等于”`IS_GE`、“等于”`IS_EQUAL`、“不等于”`IS_NOT_EQUAL`、“大于”`IS_GT`和“小于”`IS_LT`。

```:Scheme
(define IS_LE
  (lambda (num1 num2)
    (IS_ZERO (SUB num1 num2))))

(define IS_GE
  (lambda (num1 num2)
    (IS_ZERO (SUB num2 num1))))

(define IS_EQUAL
  (lambda (num1 num2)
    (AND (IS_LE num1 num2) (IS_LE num2 num1))))

(define IS_NOT_EQUAL
  (lambda (num1 num2)
    (NOT (IS_EQUAL num1 num2))))

(define IS_GT
  (lambda (num1 num2)
    (NOT (IS_LE num1 num2))))

(define IS_LT
  (lambda (num1 num2)
    (NOT (IS_GE num1 num2))))
```

# 第三章：整数和对称

---

为了解决减法无法得到负数的问题，我们现在来构造负数，从而构造出所有整数。

为了充分利用已有的结构，并且使体系尽量保持简洁，不妨使用有序对`PAIR`来构造整数`INT`。

有序对可以存储两个自然数，因此可以用左右两侧数的相对大小来表示自然数。

左右两个数的差值就是整数的绝对值。如果左边比右边大，则为负；如果左边比右边小，则为正。若两边的自然数相等，则为整数0。很自然地，可以构造出检验整数0的谓词`IS*ZERO`。

```:Scheme
(define INT
  (lambda (neg pos)
    (PAIR neg pos)))

(define *ZERO (PAIR @0 @0))

(define IS*ZERO
  (lambda (int)
    (IS_EQUAL (LEFT int) (RIGHT int))))
```

这种构造有一个缺点，那就是对于同一个整数，有无穷多种表示形式，并不优雅。这就需要构造出一个将同一个整数的不同表示标准化成唯一一种形式的函数——标准化函数`*NORMALIZE`。

```:Scheme
;整数标准化，也就是简化成至少一边为0的形式，这样就可以实现绝对值函数和符号函数了
(define *NORMALIZE
  (lambda (int)
    (IF (IS_LE (LEFT int) (RIGHT int))
        (INT @0 (SUB (RIGHT int) (LEFT int)))
        (INT (SUB (LEFT int) (RIGHT int)) @0))))
```

顺便实现了绝对值和符号函数：

```:Scheme
(define *ABS
  (lambda (int)
    (IF (IS_ZERO (LEFT (*NORMALIZE int)))
        (RIGHT (*NORMALIZE int))
        (LEFT  (*NORMALIZE int)))))

;正数返回@true; 负数返回@false
(define *SGN
  (lambda (int)
    (IS_ZERO (LEFT (*NORMALIZE int)))))
```

有了整数，自然数不再孤单。因为每一个整数，都有唯一对应的一个相反数。

因此，整数的加法和减法，本质上都是加法。这也就是说，整数是关于加法封闭的。

```:Scheme
(define *ADD
  (lambda (i j)
    (INT (ADD (LEFT  i) (LEFT  j))
         (ADD (RIGHT i) (RIGHT j)))))
```

每一个整数加上它的相反数，最终都得到单位元0，这意味着整数集合是关于0对称的。整数和加法，构成**阿贝尔群**。

整数乘法相对复杂一点：

```:Scheme
(define *MUL
  (lambda (i j)
    (INT (ADD (MUL (LEFT i) (LEFT j)) (MUL (RIGHT i) (RIGHT j)))
         (ADD (MUL (LEFT i) (RIGHT j)) (MUL (RIGHT i) (LEFT j))))))
```

乘法破坏了整数集合的对称性。因为乘法逆运算——除法——的运算结果，并不在整数集合中。为了解决这个问题，就要创造一种新的数——有理数。为了突出主线，本文就不讲有理数的构造了，我们继续看更有趣的东西。

# 第四章：递归

---

在这一章中，我们将真正见识到λ演算的魔力。

## 自然数的除法和求余

对于自然数而言，反复做加法可以得到乘法运算；而反复做减法可以得到两种运算——除法和求余。

除法是将一个数反复从另一个数上面减去，直到减不了为止，得到的结果是做减法的次数，这个次数称为“商”。而求余运算得到的是除不尽的那部分余数。除法记作`DIV`，求余记作`MOD`。（Scheme的求余函数是`remainder`）

两个数做除法，反复减掉的那个数是“除数”，越减越小的那个数是“被除数”。如果被除数比除数小，那么就没办法从被除数上减，所以减的次数就是0，也即“商”为0。反之，每多做一次减法，商就增加1，最后减到不能再减的时候，之前做过的减法的次数，就是最后得到的商。

根据上面的描述，可以利用前三章构造的基本运算写出`DIV`的定义：

```:Scheme
(define DIV
  (lambda (m n)
    (IF (NOT (IS_LE n m)) ;n>m
        @0
        (INC (DIV (SUB m n) n)))))
```

上面这段代码很好地“描述”了除法的原理，但它现在还不能帮助我们计算除法。为什么呢？

首先，`IF`的后两个参数代表两个分支，逻辑上是必须执行且只能执行一个的。但是，由于我们已经在第一章约定采用应用序求值，因此不论条件为何，两个分支都会被求值，这显然不是我们希望的结果。

为了延迟两个分支的求值，我们可以利用η-转换，将两个分支封装成λ函数，也就是将`(f a)`转换成`(lambda (x) ((f a) x))`。由于λ函数作为参数值的求值结果仍然是原来的形式，因此被封装为λ函数的分支，在求值`IF`的各个参数时，会作为一个整体，通过β-归约被扔进`IF`的函数体。这样，就将条件分支的执行推迟到了`IF`做出决定之后。

η-转换前后的两个λ项，符号形式不同、语法意义不同、抽象层次不同，但拆包后的执行效果是相同的，因此是“[外延等价](https://en.wikipedia.org/wiki/Extensionality)”的。

还有一点需要注意的是，尽管我们讨论的是“无类型”λ演算，但其实已经暗中标好了类型。比如说，接受两个参数的函数和接受一个参数的函数，显然不是同一类函数；返回值的类型不一致的两个函数，也不是同一类函数。例如，数字1`@1:(lambda (f a) (f a))`和逻辑假值`@false:(lambda (x y) y)`就不是同一类函数，因为`@1`返回的是函数调用`(f a)`，而`@false`返回的是变量`y`（指代的值），在形式上是不一致的。这种形式上的不统一，意味着他们不是“[内涵等价](https://en.wikipedia.org/wiki/Intension)”的，也就是说，他们不属于同一“类”（当然可以写出诸如`(@0 (lambda (x) x) 1)`和`(@true 1 2)`的表达式，它们的返回值是同一类型（都是“`1`”），但这反映的是执行结果的等价即“外延等价”，而不是“内涵等价”）。

考虑到这一点之后，η-转换就有了更多需要考虑的细节。例如，对于先前定义的`DIV`函数，分支`(INC (DIV (SUB m n) n))`的返回值类型是一个接受两个参数的丘奇数，因此，在做η-转换的时候，就必须相应地给它传入两个形式参数，才能保证“类型”上的正确性：

```:Scheme
(lambda (x y) (
  (INC (DIV (SUB m n) n)) x
                          y))
```

这样就可以保证η-转换后与转换前的输出都是同一“类型”，也即`DIV`返回的类型——丘奇数。

改写后的`DIV`函数如下：

```:Scheme
(define DIV
  (lambda (m n)
    (IF (NOT (IS_LE n m)) ;n>m
        @0
        (lambda (x y) ((INC (DIV (SUB m n) n)) x y)))))
```

有了`DIV`的构造经验，`MOD`就不难了。依样画葫芦，很容易写出`MOD`函数如下：

```:Scheme
(define MOD
  (lambda (m n)
    (IF (OR (IS_ZERO m) (NOT (IS_LE n m))) ;m<=n
        m
        (lambda (x y) ((MOD (SUB m n) n) x y)))))
```

至此，在λ演算的基础上，我们实现了自然数的全部四则运算，并且它们都是封闭于自然数内部的。

## Y组合子

[皮亚诺算术](https://en.wikipedia.org/wiki/Peano_axioms)

上文中，我们从无到有地实现了自然数和自然数上面的运算，其中最核心的构造方式就是“后继”。从0开始，不断地取后继数，可以枚举出“所有”的自然数。之所以要给“所有”打引号，是因为我们总是可以给“所有”自然数里面最大的那个取后继，得到的仍然是“所有”自然数。这暗示着，自然数集合是一种“自我同构”的集合。通过自我指涉以致无穷，这就是递归。

在实现除法和求余运算的时候，我们已经用到了递归。事实上，加减乘除四则运算，无一不是在后继函数基础上的递归。例如：

$$
\begin{cases}
{ADD}(0,n) = n, \\\\
{ADD}(m,n) = \mathrm{INC}({ADD}(m-1,n))
\end{cases}
$$

递归是普遍的。除了四则运算之外，还有许多问题是可以用递归的方法解决的。例如，阶乘运算`FACT`是一个非常典型的递归函数，几乎所有讲递归的文章都会提到阶乘。

```:Scheme
(define FACT
  (lambda (n)
    (IF (IS_EQUAL n @0)
        @1
        (lambda (x y) ((MUL n (FACT (DEC n)))
                       x
                       y)))))
```

目前，我们已经实现了三个递归形式的函数，也即自我调用的函数。不知道你有没有注意到，在我们写的代码中，除了`lambda`和`define`，已经没有任何“保留字”了。然而，在第一章我们提到过，λ演算并没有`define`机制，所有的函数都是匿名函数。如果函数没有名字，就不能通过名字引用自己，也就无法实现递归了。果真如此吗？

我们看一个神奇的构造。下面的函数`Y`称为**Y不动点组合子**：

```:Scheme
(define Y
  (lambda (S)
    ( (lambda (x) (S (x x)))
      (lambda (x) (S (x x))))))
```

它的神奇之处在于，将任意一个函数`F`传入Y组合子，都有：

```:Scheme
(Y F) => ( (lambda (x) (F (x x)))
           (lambda (x) (F (x x))) )
      => (F ( (lambda (x) (S (x x)))
              (lambda (x) (S (x x))) ))
      即 (F (Y F))
```

可以发现，左边的`(Y F)`和右边的`(Y F)`是同一个`(Y F)`，`(Y F)`的结果是给它自己又调用了一次`F`。这意味着，`(Y F)`就是我们寻找的能够实现自调用的递归函数，也是`F`的**不动点**。

这里的F，是一个“**高阶函数**”。所谓高阶函数，就是将有名字的递归函数的自调用部分抽象成参数，得到的新函数。例如，将阶乘函数的自调用部分`FACT`抽象成参数`f`，就得到了它的高阶函数：

```:Scheme
(lambda (f)
  (lambda (n)
    (IF (IS_EQUAL n @0)
        @1
        (lambda (x y) ((MUL n (f (DEC n)))
                       x
                       y)))))
```

使用这个高阶函数去调用Y组合子，Y组合子就会不断地将参数代表的那个真正的递归函数应用到自身，从而实现了匿名函数的递归。

> 在计算器上随便输入一个数字，反复按“cos”键，得到的结果一定会收敛到某个确定的值（弧度制下是0.739...）。这个值就是$\mathrm{cos}(x)$的不动点，也就是$\mathrm{cos}(x) = x$的根。

> ![余弦函数的不动点](./image/misc/cos_fixed_point.jpg)

Y组合子的存在，意味着λ演算可以实现递归，也就意味着对于λ函数而言，名字的有无并不是一个重要的问题。因此，为了使用上的方便，各种编程语言都引入了类似`define`的语法。可见，`define`的本质是一块甜甜哒语法糖，既然如此，我们还是继续给函数起名字好了。

> Scheme提供了多种变量定义的机制，如`let`、`let*`和`letrec`。这些机制有非常微妙的区别，但是它们的本质都是将局部作用域的外面包裹了一层，形成了新的“高阶函数”。例如，下面的`let`形式建立了一个局部变量`C`：

> ```:lisp
(lambda (x)
  (let ((C 100))
       (+ x C)))
```

> 它跟下面这种普通的λ表达式的执行效果是相同的：

> ```:lisp
(lambda (x)
  ((lambda (C)
     (+ x C)) 100))
```

> JavaScript是一款Scheme血统非常明显的语言。在JavaScript中，可以用`var`关键字来声明变量。`var`有所谓“变量提升”的特性，也就是，在一个函数作用域中，只要出现了`var`声明，那么被声明的变量在整个作用域内部都是有效的。这种特性的原因显然是继承了Scheme的`let`的特性。

尽管Y组合子看起来很奇妙，但是我们发现，它实际上是不“收敛”的。由于`(x x)`的存在，在应用序求值中，代换的过程会无穷无尽地继续下去。为了解决这个问题，我们可以使用以往的经验，即将`(x x)`封装成`(lambda (y) ((x x) y)`，从而延迟对它的求值。注意到这种封装只适用于单参函数，这就是说，不论目标递归函数有几个参数，最好是经过柯里化，转换成单参函数。这在一定程度上牺牲了简洁性，却换来了通用性。这个经η-变换，将自调用部分`(x x)`封装起来的Y组合子，称为**Z组合子**，它是Y组合子在应用序求值策略下的实现。

> 在后文中，为了使用Z组合子，有些多参数函数会写成柯里化之后的形式。

有了Z组合子，我们就可以写出可执行的、纯粹的λ演算版本的阶乘函数了：

```:Scheme
((lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y))))))
 (lambda (f)
     (lambda (n)
       (IF (IS_EQUAL n @0)
           @1
           (lambda (x y) ((MUL n (f (DEC n)))
                          x
                          y))))))
```

现在已经不需要任何（除了`lambda`的）保留字了。但是很复杂，对不对？所以`define`这块语法糖不吃白不吃。

刚才实现的这些递归函数，都只在内部调用自己一次，如果调用多次呢？这样的递归就是所谓的“树形递归”。最著名的树形递归就是斐波那契数列了：

```:Scheme
(define Fib
  (lambda (num)
    ((Z (lambda (f)
          (lambda (n)
            (IF (OR (IS_EQUAL n @0) (IS_EQUAL n @1))
                @1
                (lambda (x y) ((ADD (f (SUB n @1)) (f (SUB n @2))) x y))
            )))) num)))
```

这段代码是可以运行的。理论上，树形递归也是一种普通的递归，它与递归函数有相同的计算能力。（见[计算理论学习笔记](./computation-theory-note.html)）

![名可名，非常名（画师：infinote，PixivID：54853954）](./image/misc/iwazaru.jpg)

至此，我们在纯粹λ演算的框架内，实现了递归。有了递归，终于可以看到地平线上慢慢浮现出来的“万能机器”的幻影。

> 列宁有一次发表演讲：“共产主义已经出现在地平线上。”台下有个工人问身边的教授：“什么是地平线？” 教授说：“地平线是一条假想的线，天和地在那里相接，但是当你走近它时，你就会发现它会离开你，然后又出现在远方。——苏联笑话

# 第五章：结构

---

### 线性列表

数学是一门关于“结构”的学问。而结构是一种抽象的东西，看不见摸不着，却又无处不在。数学的学习，以及数学本身的发展，就是一个逐渐从具体的事物中剥离掉表象，得到某种通用的东西的过程。抽掉了表象，就是“抽象”，也就不能靠直觉的描述去表达了。那么靠什么呢？答案是：靠它的**行为**。

[线性表](https://en.wikipedia.org/wiki/List_\(abstract_data_type\))是一种抽象的结构，它可以这样描述：

- “空表”是线性表；
- 单个的“元素”是一个线性表；
- 在线性表的**前面**增加**一个**元素，得到的结构也是线性表。

如果写成BNF，就是：

```
<List> ::= <NullList>
<List> ::= <Element>
<List> ::= <Element> <List>
```

可见，线性表是一种递归的数据结构。

线性表有一个初始结构和四种基本的操作：

- NULL_LIST：空表
- CONS：在表的开头增加一个元素
- CAR：取表的第一个元素
- CDR：取表的第一个元素之后的子表
- NULLLIST?：判断是否空表

只要构造出这些“行为”，就相当于构造出了线性表。关于CAR和CDR含义，可以参考[维基百科](https://en.wikipedia.org/wiki/CAR_and_CDR)。

首先，我们可以利用先前定义的有序对和`@true`，定义空表和其他操作。在下面的代码中，之所以使用`@true`定义空表，是因为这样比较方便定义谓词`NULLLIST?`。

```:Scheme
(define NULL_LIST
  (PAIR @true @true))

(define NULLLIST?
  (lambda (list)
    (LEFT list)))
```

以`PAIR`为基础构造，可以实现`CONS`、`CAR`和`CDR`三个基本操作。实现的思路是这样的：每一个`PAIR`，都是线性表中的一个枢纽，它的左侧是布尔值，如果为`@true`，意味着右侧的子表是空表；右侧是一个子`PAIR`，存储一个元素以及后面的表结构。图示如下：

![层层嵌套的二元组](./image/misc/church-list.png)

```:Scheme
(define CONS
  (lambda (e l)
    (PAIR @false (PAIR e l))))

(define CAR
  (lambda (list)
    (LEFT (RIGHT list))))

(define CDR
  (lambda (list)
    (RIGHT (RIGHT list))))
```

> 如果执行`(CAR @1)`或者`(CDR NULL_LIST)`会怎样呢？炸了。

> 因此引入类型是非常自然的。目前暂不考虑。

有了这三个基本操作，就可以构造出一些实用函数了。

```:scheme
;;数组元素计数
(define COUNT
  (lambda (l)
    ((Y (lambda (f)
          (lambda (list)
            (IF (NOT (NULLLIST? list))
                (lambda (x y) ((INC (f (CDR list)))
                               x
                               y))
                @0))))
     l)))

;; 闭区间，注意Currying
(define RANGE
  (lambda (m n)
    (((Y (lambda (f)
          (lambda (a)
            (lambda (b)
            (IF (IS_LE a b)
                (lambda (z) ((CONS a ((f (INC a)) b))
                               z ))
                NULL_LIST
            )))))m)n)))

;; 投影函数：用于取出列表的第index个元素（从@0开始）
(define PROJ
  (lambda (list index)
    ((((Y (lambda (f)
            (lambda (l)
              (lambda (i)
                (lambda (j)
                  (IF (IS_EQUAL i j)
                      (CAR l)
                      (lambda (x y) ((((f (CDR l)) i) (INC j)) x y))
                   ))))))list)index)@0)))
```

利用λ演算的一等函数特性，我们可以将列表遍历操作抽象成高阶函数，而将具体的业务逻辑作为一等函数传入高阶函数。这样，我们就不需要每次都写麻烦的迭代代码了。常见的高阶函数有`MAP`、`FOLD`（`REDUCE`）等。

```:scheme
;高阶函数Fold和Map
(define FOLD
  (lambda (list init func)
    ((((Y (lambda (f)
          (lambda (l)
            (lambda (i)
              (lambda (g)
                (IF (NULLLIST? l)
                    i
                    (lambda (x y) (
                      (g (CAR l) (((f (CDR l)) i) g))
                      x y))
                ))))))list)init)func)))

(define MAP
  (lambda (list func)
    (((Y (lambda (f)
           (lambda (l)
             (lambda (g)
               (IF (NULLLIST? l)
                   NULL_LIST
                   (lambda (x) ((CONS (g (CAR l)) ((f (CDR l)) g)) x))
                )))))list)func)))
```

### 二叉树

树状结构也是一种无处不在的重要结构。鉴于多叉树都可以使用二叉树表示，因此这里我们只构造二叉树。

二叉树也是一种可以递归定义的结构：

- 单个元素称为**节点**
- 不包含任何节点的**空树**是二叉树
- 每个节点都有至多两个子二叉树，分别称为左子树和右子树

与列表类似，我们需要构造下面这些基本操作：

- 空树：`NULL_TREE`
- 判断空树的谓词：`NULLTREE?`
- 取节点：`NODEOF`
- 取左子树：`LEFT_SUBTREE`
- 取右子树：`RIGHT_SUBTREE`
- 构造一棵树：`MAKE_TREE`

仍然以`PAIR`为基本单元，通过`PAIR`的嵌套和组合，就可以构造出来：

```:scheme
(define NULL_TREE
  (PAIR @true @true))

(define NULLLIST?
  (lambda (bt)
    (LEFT bt)))

(define NODEOF
  (lambda (bt)
    (LEFT (RIGHT bt))))

(define LEFT_SUBTREE
  (lambda (bt)
    (LEFT (RIGHT (RIGHT bt)))))

(define RIGHT_SUBTREE
  (lambda (bt)
    (RIGHT (RIGHT (RIGHT bt)))))

(define MAKE_TREE
  (lambda (e left right)
    (PAIR @false (PAIR e (PAIR left right)))))
```

这里可以发现，空树和空表的构造是一致的；整个树状结构的构造，跟线性表的构造也有很大的相似性。因此，完全可以说，线性表可以看成是一棵极度不平衡的二叉树。

事实上，我们完全可以采用另一种方式来实现上面几个基本操作，例如：

```:scheme
(define NULL_TREE ...)

(define NULLLIST? ...)

(define NODEOF ...)

(define LEFT_SUBTREE ...)

(define RIGHT_SUBTREE ...)

(define MAKE_TREE ...)
```

尽管实现方式不同，但是从效果上来说，两种实现是等效的。因此，我们可以说，上面定义的几种操作，构成了对二叉树这一通用结构的接口定义。我们通过约定接口的方式，将二叉树封装进一套功能明确的接口定义中。这样，即便接口的内部实现有变化，只要接口功能不发生变化，外面的用户就不会感觉到变化。将这种思想丰富起来，便产生了对象与类、原型链等花样百出的数据封装手段。

# 第六章：解释

---

## 符号和解释

## 一个简单的计算器/CAS

# 第七章：无穷

---

## 环境和控制流

## 数据即代码——自我解释

## 通用机器

# 参考资料选列

---

- Tom Stuart, 张伟（译）. [计算的本质](https://book.douban.com/subject/26148763/). 人民邮电出版社, 2014.
- Friedman D P, Wand M. [Essentials of Programming Languages, 3rd Edition](http://www.eopl3.com/)[M]. The MIT Press, 2008.
- [https://en.wikipedia.org/wiki/Lambda_calculus]()
- [https://en.wikipedia.org/wiki/Church_encoding]()
- [http://www.yinwang.org/blog-cn/2013/03/31/purely-functional]()

