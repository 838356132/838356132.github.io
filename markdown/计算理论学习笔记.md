#!metadata
{
    "title":"计算理论学习笔记",
    "titleImage":"",
    "type":"原创",
    "date":"2017-09-22",
    "author":["Mikukonai"],
    "tags":["函数式编程","计算机科学"]
}

#!content

> 本文是《可计算性与计算复杂性导引》（张立昂）阅读笔记。

> 本文旨在通过读书笔记的形式，复述书中要点，并且适时提出自己的疑问、联想和观点。同时，力求在理解基本概念的基础上，构建一个完整的知识体系和逻辑框架，这是阅读的目的所在。

# 1.程序语言和可计算函数

## 1.1 丘奇-图灵论题

**直观可计算与（等价）图灵机可计算是同一回事。**基于这个“论题”，只要是图灵机可实现的计算，那么就认为它是直观可计算的。所谓的直观可计算并不是一个严格的形式化概念，所以这个论题也只能叫“论题”。因为还没有发现“直观可计算”但图灵机无法计算的算法，所以大家默认CT论题是正确的。

## 1.2 程序设计语言

书中给出的语言有四条基本语句：空语句、增量、减量和条件（为0）跳转。但是这个指令集完备吗？这里暂时没有给出回答。

所有变量及其取值组成的有穷映射称为程序的**状态**，这个在调试的时候很清楚。

程序状态与下条指令组成的有序对称为程序的**快照**。

对某个非终点快照按照指令行为加以解释，可得到它的**后继快照**。

由快照→后继快照组成的有穷快照序列称为一个**计算**。如果程序陷入死循环，或者不考虑资源消耗的无穷递归，那么快照序列就是无穷的，这就属于不可计算了。无法在有限的步骤内给出有意义的结果，就属于是不可计算。

当然，对于计算机（尤其是图灵机）而言，获得结果并不是唯一的目的，计算过程中的“**副作用**”也是需要加以利用的。比如说操作系统本质上就是一个大的死循环，它并不以输出什么为目的，它只要一直运转就行了，就像一台自动扶梯一样。很多人用C语言写程序的时候，尤其是初学者写嵌入式程序的时候，往往会忽视返回值的问题，甚至无视规范写出`void main()`这样的函数，这就是忽视了程序的“初衷”，毕竟跑马灯不需要返回什么结果。所以我们说C语言是“过程式”语言，因为它非常关注计算过程本身，也引导程序员通过分析计算过程来编写程序。

## 1.3 可计算性与可计算函数

The Little Schemer 第九章给出了这样的一个函数：

```:Scheme
(define looking
  (lambda (a lat)
    (keep-looking a (pick 1 lat) lat)))

(define keep-looking
  (lambda (a sorn lat)
    (cond ((number? sorn) (keep-looking a (pick sorn lat) lat))
          (else (eq? sorn a)))))
```

这个函数的特点是：对于某些输入，可以终止并输出结果；但对于另外一些输入，例如`(2,1,a)`，程序就会陷入死循环，永远无法停止。

所谓的数论函数，就是从自然数笛卡尔积集到自然数的函数。下文首先考虑数论函数。

设程序所计算的（数论）函数为$\psi (\mathbf \sigma )$，其中$ \mathbf \sigma $是初始状态，也就是算法的输入参数。对于程序终止且输出有效结果的情形，$\psi (\mathbf \sigma ) = Y $，其中$ Y $是最终状态中代表结果的变量；对于程序无法终止的情形，$\psi (\mathbf \sigma ) \uparrow$。函数$ \psi $在这里显然是一个部分函数，称为**部分可计算函数**。如果它恰好是一个全函数，也就是说，并没有那种能够导致死循环的输入，那它就是**可计算函数**。

**谓词**是值域为{0, 1}的全函数，相应地存在**可计算谓词**的概念。

# 2.原始递归函数

## 2.1 什么是原始递归函数

### 2.1.1 合成和原始递归操作

**合成**操作可以理解为函数的嵌套调用。（部分）可计算函数合成后得到的函数也是（部分）可计算的。

**原始递归**操作的一般形式如下：

$$
\begin{cases}
{prf}(\sigma , 0) = {init}(\sigma), \\\\
{prf}(\sigma , t + 1) = {step}(\sigma, {prf}(\sigma , t) , t)
\end{cases}
$$

写成Scheme是：

```:Scheme
(define prf
  (lambda (input t)
    (cond ((= t 0) (init input))
          (else (step input (prf input (- t 1)) (- t 1))))))
```

函数`prf`是`init`和`step`两个函数经过原始递归得到的。如果`init`和`step`都是可计算的，那么`prf`也是可计算的。

函数`init`给出了递归终止条件下的、在某个输入上的、原始递归函数的返回值；而函数`step`则给出了每次递归要对上次递归的结果执行怎样的处理。

### 2.1.2 由初始函数构造原始递归函数

合成和原始递归是构造原始递归函数的基本规则，按照这些规则将**初始函数**进行有限次处理，得到的就是**原始递归函数**。**原始递归函数是可计算的。**

初始函数有：

- 后继函数（+1，加法器）
- 零函数（返回常数0）
- 投影函数（查线性表，译码器）

在图灵机的语境下，这三个函数非常容易理解，也非常容易实现。但是在lambda演算的语境下，则显得不够简洁。例如，使用Scheme实现的列表投影函数，就不够“基本”。造成这种现象的根本原因是二者数据结构的基础不同：图灵机基于线性表和状态机，而lisp是基于嵌套表的。这本薄薄的教材暂时没有就这个问题给出更多解释。

虽然写出来会很繁琐，但是我觉得仍然有必要将感兴趣的函数用Scheme写出来。

在书中举出的若干个例子里，前驱函数是构造起来比较巧妙的一个。由于后继函数只能提供后继信息，在下一次递归后，调用前的前驱信息将丢失，因此必须以某种方式，在递归过程中保存前驱信息。对于Scheme来说，可以利用原生的表结构存储(前驱,后继)信息，每次递归调用时，同时为二者+1，递归结束时取前驱项返回即可。代码如下：

```:Scheme
;前驱函数
(define prec
  (lambda (n)
    (define prec-iter
      (lambda (x pair)
        (cond ((= x 0) 0)
              ((= x (cdr pair)) (car pair))
              (else (prec-iter x (cons (succ (car pair)) (succ (cdr pair))))))))
    (prec-iter n '(0 . 1))))
```
基于这种想法，还可以有更多简洁的写法。归根结底，都是通过保存“状态”来实现。对于命令式编程而言，状态就是存储器格局；对于函数式编程而言，状态就是堆或者栈中的参数列表。

至于补码加法实现减法这种邪术，和现在所讨论的问题已经不是同一个层次的问题了。

参见：SICP习题1.11。

对于谓词，同样有**原始递归谓词**的说法。可以证明，条件分支函数是原始递归函数。

**迭代**运算定义为原始递归函数的有限累加或者累乘，迭代后的原始递归函数也是原始递归函数。

**有界量词**可以转化到有限次的谓词迭代运算，因此使用了有界量词的谓词也是原始递归谓词。Scheme代码如下：

```:Scheme
;有界量词
(define arbitrary
  (lambda (p max)
    (cond ((= 0 max) (p max))
          (else (and (p max) (arbitrary p (- max 1)))))))
(define exist
  (lambda (p max)
    (cond ((= 0 max) (p max))
          (else (or (p max) (exist p (- max 1)))))))
```

利用现有的量词，可以构造出素数判断谓词如下：

```:Scheme
;y是否整除x
(define idiv
  (lambda (y x)
    (exist (lambda (t) (= x (* y t))) x)))

;Prime
(define is-prime
  (lambda (x)
    (and (> x 1) (arbitrary (lambda (t) (or (= t 1) (not (idiv t x)))) (- x 1)))
  ))
```

### 2.1.3 极小化和递归函数

**有界极小化**运算求谓词$ P(\sigma ,t)$在输入$\sigma$的条件下，取得真值的$t$的最小值；如果找不到最小值，则返回0。记作：

$$ \mathrm{min}_{t \le y}(P(\sigma ,t)) $$其中，y是极小化上界。

例如对于谓词$P(t)=5 \ge t$，其极小化的结果就是5，因为5是使谓词为真的最小自然数。

利用有界极小化算子和其他函数，可以拼凑出求素数的函数：

```:Scheme
;有界极小化（itor赋0）
(define minimalization
  (lambda (predicate max itor)
    (cond ((> itor max) 0)
          ((predicate itor) itor)
          (else (minimalization predicate max (+ itor 1))))))

;阶乘
(define fac
  (lambda (n)
    (cond ((= n 0) 1)
          (else (* n (fac (- n 1)))))))

;求第n个素数
(define prime
  (lambda (x)
    (cond ((= x 0) 0)
          (else ((lambda (y z) (minimalization (lambda (t) (and (is-prime t) (> t y))) z 0)) (prime (- x 1)) (+ 1 (fac (prime (- x 1)))))
          ))))
```

如果取消有界极小化的上界限制，则得到一般的**极小化**算子。取消了上界的极小化算子不再是全函数，因为有可能永远也找不到最小成真赋值。

因此定义**部分递归函数**如下：由初始函数经过

- 有限次合成
- 原始递归（迭代的本质是原始递归，量词的本质是迭代）
- 极小化

三种运算得到的函数称作部分递归函数。其全函数就是传说中的

> **递归函数**。

## 2.2 “编码”的奥秘

### 2.2.1 配对函数

$$ \langle x,y \rangle =2^x(2y+1)-1 $$

### 2.2.2 哥德尔（Gödel）数

进制数可以看做是对自然数的一种编码方式，它将一个自然数编码为一个（并不唯一的）基本数字符号序列。与此相对，哥德尔数试图将有穷数列编码为一个唯一的自然数，其编码规则如下：

$$ [{array}(1:n)] = \prod_{i=1}^n {\mathrm {Prime}(i)^{ {array}[i]} } $$

注意，在哥德尔编码语境下的数组，约定起始下标是1。

类似于$k$进制数，哥德尔数也是带权数，只不过哥德尔数的基数是（第$i$个）素数。哥德尔数与进制数有这样几点不同：

- 哥德尔数是用乘的，而进制数用加；
- 任何有穷数列经哥德尔编码得到的哥德尔数是唯一的，而进制数一定不唯一（例如十进制25和025代表同一个数）；
- 哥德尔数的计算顺序是从左到右的，而进制数一般是高位在左的；

每一个有穷数列经哥德尔编码都可以得到唯一哥德尔数，但是反过来，哥德尔数并不对应唯一的有穷数组，例如{1,2}和{1,2,0,0}的哥德尔数是一样的，都等于18。这并不妨碍使用，尤其是解码工作。

哥德尔数的解码同编码一样是原始递归的。为了求某个哥德尔数$gcode$对应的数列的某一项（就第$i$项吧），因为所有因子项必然是整数，只需要考察整除$gcode$的第$i$个素数的几次幂，这个次数的最大值就是原数列的第$i$项，再多一项就不可能整除了。只要找到了这个不能整除的次数的最小值，就找到了原数列的第$i$项。如果找遍了所有的次数（最大肯定不能超过$gcode$）还没有遇到无法整除的情况，那就是0了。这与极小化算子的操作步骤是一致的，所以解码算法如下：

$$ \mathrm {GDecoding}(gcode,i) = \mathrm {min}_{t \le gcode} (\lnot (\mathrm {Prime}(i)^{(t+1)} | gcode)) $$

但由于哥德尔数不可能是0，为了使解码算法成为全函数，规定对于每个$i$，$ \mathrm {GDecoding}(0,i) = 0 $；并且对于数组中没有的下标，函数也返回0。

> 以上：2017.9.22

有了哥德尔数之后，通过极小化算子也可以求出对应的最短数组的长度。

用Scheme编写哥德尔数编解码算法如下：

```:Scheme
;哥德尔数编码（itor赋1）
(define g-encode
  (lambda (ln itor)
    (cond ((null? ln) 1)
          (else (* (exp (prime itor) (car ln)) (g-encode (cdr ln) (+ itor 1)))))))

;哥德尔数解码
(define g-decode
  (lambda (gcode index)
    (minimalization (lambda (t) (not (idiv (exp (prime index) (+ t 1)) gcode))) gcode 0)))

(g-encode '(3 2 1) 1)
(g-decode 360 1)
```

## 2.3 还有一些特殊的递归也是原始递归

除了原始递归之外，书中还介绍了联立递归、多步递归和多变量递归。联立递归通过形式上的变换就可以得到原始递归的形式，所以联立递归无疑是原始递归。但对于多步递归和多变量递归，事情就没有那么简单了。

### 2.3.1 多步递归的可计算性证明

所谓的多步递归，就是每次递归都要用到不止一个过往的递归结果，甚至用到所有的递归结果。求斐波那契数列的递归过程就是一个典型的多步递归。多步递归的复杂性在于，它的递归展开和回溯过程并不是线性的，而是树状的。为了证明多步递归的原始递归本质，书中考虑了极端情况——所有过往计算的返回值都有用到。考虑函数$mr$：

$$
\begin{cases}
{mr}(0) = {init}, \\\\
{mr}(t + 1) = {step}({mr}(0) , {mr}(1) , ... , {mr}(t) , t)
\end{cases}
$$

这里特地把书中的累加抽象成了原始递归的step函数。这个step函数接受一个参数列表，其中就有从0到$t$的所有过往结果。将它们视为数列，计算哥德尔数：

$$ {MR}(t) = \prod_{i=0}^{t} {\mathrm {Prime}(i+1) ^{mr(i)}} \tag{1}$$

对其进行解码，就可以计算出每一个${mr}(i)$的值：

$$ {mr}(i) = \mathrm {GDecoding}({MR}(t), i+1) , 0 \le i \le t \tag{2}$$

之所以要这样构造，是因为已知哥德尔数的编解码过程都是原始递归，如果可以证明${MR}(t)$是原始递归的话，说明${mr}(t)$也是原始递归。

那么就用(2)右边的式子换掉$ {mr}(t+1) $的右边的各个函数调用，就得到新的含有${MR}(t)$的形式：

$$ {mr}(t + 1) = {step}(\mathrm {GDecoding}({MR}(t), 1) , \mathrm {GDecoding}({MR}(t), 2) , ... , \mathrm {GDecoding}({MR}(t), t+1) , t) \tag{3}$$

进一步将${step}(\mathrm {GDecoding}(\cdot, 1) , \mathrm {GDecoding}(\cdot, 2) , ... , \mathrm {GDecoding}(\cdot, t+1) , t)$抽象为${gstep}(\cdot, t)$，${gstep}$显然也是原始递归函数。那么$ {mr}(t + 1) $就可以写成更简洁的形式：

$$ {mr}(t + 1) = {gstep}({MR}(t), t) \tag{4}$$

到这里，就可以开始考虑${MR}$本身了。因为已经有了${mr}(t + 1)$，所以将$ {MR}(t+1) $写成递归的形式，以暴露出${mr}(t + 1)$：

$$ {MR}(t+1) = {MR}(t) \cdot \mathrm {Prime}(t+2)^{mr(t+1)} \tag{5} $$

将(4)代入(5)得到：

$$ {MR}(t+1) = {MR}(t) \cdot \mathrm {Prime}(t+2)^{ {gstep}({MR}(t),t)} \tag{6} $$

现在可以进一步将$ (\bullet) \cdot \mathrm {Prime}(t+2)^{ {gstep}(\bullet,t)} $抽象为$ {GSTEP}(\bullet,t) $，简化(6)得到：

$$ {MR}(t+1) = {GSTEP}({MR}(t),t) \tag{7} $$

由于$ {gstep} $是原始递归函数，所以$ {GSTEP} $也是原始递归函数。这样的话，(7)式以及${MR}(0)=2^{init}$的事实说明${MR}$也是原始递归函数。

既然${MR}$是原始递归函数，那么**多步递归${mr}$也是原始递归函数，也就是可计算函数。**

多变量递归可计算性的证明同样利用了哥德尔编解码。

## 2.4 阿克曼（Ackermann）函数

阿克曼函数可以说是可计算函数里面的一股清流了。前段时间在做SICP的习题1.10时就觉察出这个函数的变态之处，但是当时并不晓得这个函数的意义所在。The Little Schemer也有专门提到这个函数。从实际意义上来说，这个函数的增长阶极高，以至于没什么实际用处；但是在可计算理论中，这个函数被证明是可计算的并且是非原始递归的。它的存在，意味着“可计算”并不等价于“原始递归”。

> 原始递归是可计算的充分条件，但不是必要条件。

> 以上：2017.9.23

## 2.5 字函数的可计算性

2.2.2节中，已经考虑到了进制数这一编码形式。进制数的实质是字符串，所使用的字母表就是基本数字和一些其他的字母。书中证明，进制数的编解码是原始递归的，并且通过舍弃“0”这一字符，避免了进制数的不唯一性。经过编码的字函数，本质上是数论函数。由于字函数编解码过程都是原始递归的，所以经进制数编码的可计算（部分可计算、原始递归）数论函数，即对应的字函数，也是可计算（部分可计算、原始递归）的；并且可以证明，这一结论不受字母表符号顺序的影响。

#### Ex 2.1 原始递归性证明

试证明：仅在有穷个点取非零值，其余点取值均为0的函数$f(x)$必为原始递归函数。

**证明**：设$f(i)$为非零函数值，$I$是非零取值自变量集合，$i \in I$。则构造包含所有非零函数值的有穷数列$A=\{f(i)\}$，其中$f(i)$的下标是$i$，其余下标不属于$I$的项都等于0。因此可以计算出$A$的哥德尔数

$$ {gcode} = \mathrm {GEncoding} (A) $$

对其进行解码：

$$ g(x) = \mathrm {GDecoding} ({gcode}, x) $$

若$x \notin I$，则$g(x)=f(x)=0$；若$x \in I$，则$g(x)=f(x)\neq 0$。也就是说，$g(x)=f(x)$。

由于$\mathrm {GDecoding}$是原始递归的，因此$f(x)$也是原始递归的。原命题得证。

书中将其构造为反向函数+时域平移+求和的形式，从而构造性地证明了题设函数的原始递归性。这很像表达离散时域信号的方式。

#### Ex 2.12 最大公约数的原始递归性

试证明：最大公约数`gcd(x,y)`是原始递归函数。

**证明**：由于有界极大化是原始递归，并且$\mathrm {GCD}(x,y) = \mathrm {max}_{t\le y} (t | x \land t | y)$，因此`gcd`是原始递归的。

# 3.通用程序

前面两章初步构建了基于递归函数的计算模型。为了在既有的数论基础上研究“程序”，首先要对程序进行编码，得到的就是“代码”。代码的存在，消除了数据与程序的界限，也因为代码的无穷尽性，让人们看到了递归函数的“能”与“不能”。

## 3.1 程序的代码

代码，就是指代程序的编码。书中，使用配对函数为快照进行编码，使用哥德尔数对计算过程（即快照序列）编码进行编码。为了避免麻烦，规定最后一条语句的后面不允许再有空语句。由于哥德尔编解码和配对函数都是可计算的，因此每一个程序都可以得到它的编码。又由于空指令的快照编码（被钦定）为0，所以程序末尾的空语句并不会影响程序的哥德尔编码，这样就保证了**①每一个程序都对应唯一的一个自然数**。反过来，对于任意的一个整数，**②总可以通过解码得到它对应的程序**，虽然这样得到的程序可能（大概率的可能）并没有什么卵用。这样，就保证了**每一个程序都与自然数有一一对应的关系**。

程序，也即部分可计算函数与自然数的这种双射关系，是后面许多术语带有“枚举”二字的根本原因。因为我们可以通过（递增地）枚举所有自然数，得到所有可能的程序，如《计算的本质》书中妙语所言，只要你愿意等待，总可以枚举出诸如Ajax或者Windows这样的伟大程序然后回家睡觉。

## 3.2 停机问题

http://blog.csdn.net/pongba/article/details/1336028

**假设**有一个神奇的程序`(isHalt p x)`，它计算谓词$\mathrm {HALT}(p, \mathbf x)$，这个谓词可以针对任何一个程序，回答在某个输入上该程序可否停机。于是图灵构造了这样的一个程序：

```:Scheme
(define wtf
  (lambda (p x)
    (cond ((isHalt p x) (eternity x))
          (else #t))))
```

用`wtf`和任意输入`x`去调`wtf`，也就是执行`(wtf wtf x)`：如果`wtf`可以停机，那么它本身就会陷入`(eternity x)`的循环中无法停机；如果`wtf`不能停机，那么它本身又会立即返回值而停机。这个矛盾意味着，并不存在计算谓词$\mathrm {HALT}$的程序。也就是说：

**定理3.1 停机问题不可计算**

我们不可能在有限的时间内判断一个程序在某个输入上能否停机，**停机问题是不可计算的**。

然而，停机问题并非唯一的不可计算问题。由于自然数集上的函数集的势是大于$\aleph_0$的，所以这种不可计算的问题应该说是非常“多”了，sad。

证明停机问题不可计算的关键就在于构造自我指涉，而自指的技巧，早在康托尔证明实数集不可数的时候，就已经开始使用了。

### 对角化方法

对角化方法是康托尔提出的，是用来证明$(0,1)$不可数的一种巧妙的方法。

所谓“可数”，指的是集合中的每个元素都可以与自然数建立一一对应的双射关系。假设$(0,1)$可数，那么存在函数$f(i),i\in \mathbb N$与集合中**每一个数**相一一对应。将$(0,1)$内的每一个数都写成十进制的无限小数（有限小数在末尾添加无穷个0），每个数写一行。并且，表中不允许存在以999...结尾的数字。以小数的序号为行数，小数的位序号（从0开始吧）为列数，列出下表：

| |0|1|2|3|4|5|...|
|-----------------|
|0|?| | | | | |...|
|1| |?| | | | |...|
|2| | |?| | | |...|
|3| | | |?| | |...|
|4| | | | |?| |...|
|5| | | | | |?|...|
|...| | | | | ||...|

设$(0,1)$内的某个数$r$的每一位$i$都与$f(i)$的第$i$位（也就是上表对角线上的问号）不等（例如循环加一），这样$r$仍然是$(0,1)$内的实数，但是与表中每一个$f(i)$都不相等。也就是说，构造出了不在上表中的，然而却真实存在的$(0,1)$内的实数。但根据假设，$f(i)$可以对应所有的实数，这就引起了矛盾。最终得到结论：$f(i)$是不存在的，$(0,1)$不可数。

程序可以通过编码转化为自然数，`wtf`程序的构造实际上也是利用了对角化方法。停机函数`isHalt`接受程序（代码）和程序的输入，输出表示程序能否在输入上停机的布尔值。假设`isHalt`可计算，那么可以列出这样一张表：以程序代码为行数，以程序输入为列数，表格内容是输出的布尔值，如下：

|      |0|1|2|3|4|5|...|
|----------------------|
|Code:0|?| | | | | |...|
|Code:1| |?| | | | |...|
|Code:2| | |?| | | |...|
|Code:3| | | |?| | |...|
|Code:4| | | | |?| |...|
|Code:5| | | | | |?|...|
|...| | | | | ||...|

表中对角线上的元素代表某程序以自己（的代码）为输入时能否停机。现在不妨构造这样一个程序$P$：对于**任何**程序（代码）$i \in \mathbb N$，将其输入程序$P$的停机情况$\mathrm {isHalt}(P, i)$，都与它以自己为输入的停机情况$\mathrm {isHalt}(i, i)$相反。这样，$P$就不属于表中的任何一行，也就是说，$P$是不可构造的，矛盾。这就意味着停机谓词是不可计算的。

> 总感觉递归是人类思维的一个奇点、一个bug。

> 以上：2017.9.25

## 3.3 通用程序

这一节论述了这样一个事实：**可以构造这样一台计算机：它接受某个程序（的代码）以及该程序的输入作为输入，输出的结果就是输入程序的输出结果。**这意味着宿主机器是具有**通用性**的，它可以模拟任何一台其他的机器。在Windows系统里面可以运行Ubuntu虚拟机，在Ubuntu虚拟机中可以运行Python解释器，在Python解释器中可以运行Lisp解释器，这个Lisp解释器同样可以解释其他的Lisp程序……如此直至无穷，唯一的限制便是时间和空间，以及递归集之外无法穷尽的思维角落。通用性定理是计算机的理论基础，揭示了“程序即数据”最本质的原因。

**定理3.2 通用性定理**

所有程序可通过哥德尔编码与自然数集合建立一一对应关系。设程序$P$的代码为$p$，其计算的部分可计算函数为$\psi (\mathbf x)$，其中$\mathbf x$是程序的输入（向量）。现有函数

$$\Phi (\mathbf x, p) = \psi (\mathbf x)$$

当$p$取0、1、2……即可枚举出**所有**的部分可计算函数。上式中，$\Phi $体现出解释器的行为，即以程序代码为输入，以输入程序的输出为自己的输出。可以证明，函数$\Phi (\mathbf x, p)$都是部分可计算的。这就是通用性定理。

由于$\Phi $本身是部分可计算的，所以同样可以构造出解释$\Phi $的$\Phi (\Phi)$，也就可以构造出解释$\Phi (\Phi)$的$\Phi (\Phi (\Phi))$……这是好事，也是坏事。好事是总可以通过恰当的封装和抽象去方便地实现某种功能，而不削弱功能；坏事是我们似乎看到了图灵等价计算模型（部分递归函数类的计算能力与图灵机是等价的）的计算能力极限，无论如何抽象，都不能突破计算能力的天花板……

**定理3.3 计步定理**

通用性证明的过程中构造了计步谓词$\mathrm {STP}(\mathbf x, p, t)$及其对应的程序，该谓词表示代码为$p$的程序能够在$\mathbf x$的输入下在$t$步后停机。既然可以构造出计步谓词对应的程序，意味着计步谓词是可计算的。$\mathrm {STP}$与$\mathrm {HALT}$的区别有点像有界极小化和极小化的区别。至于计步谓词为何是可计算的，其实很容易理解，如果在有限步骤内没有结束，则返回false，无论如何总能返回一个结果，所以是可计算的。

撰文时恰好发现一个牛逼的Quine，在这里：https://github.com/mame/quine-relay

## 3.4 递归可枚举集

从第一章的`looking`程序可以看到，对于部分可计算函数来说，它们的定义域是自然数集的子集。我们已经在3.1中知道，部分可计算函数，也就是“程序”的个数是可数的，那么，所有部分可计算函数的定义域所构成的集合，同样是可数的，并且不会比自然数集合要“多”。可是问题在于，自然数集的全体子集构成的集合并不是可数的，也就是说，部分可计算函数的定义域，比自然数集的子集要少得“多”。既然我们可以枚举出所有部分可计算函数的定义域，因此，给这种并不平凡的集合类起了个名字——递归可枚举（recursively-enumerable，r.e.）集合。

形式化地表述就是，如果存在部分可计算函数$g(x)$，使得

$$ E=\{x\in \mathbb N | g(x) \downarrow \} $$

则称$E$为**递归可枚举集**。

如果一个自然数有幸成为r.e.集的元素，那么它必然导致某个程序停机。反过来，如果一个自然数可以导致某个程序停机，那么它必定是某个r.e.集的元素。然而，如果一个自然数并没有使某个程序停机，那么它**未必不属于**该程序对应的r.e.集，因为它可能只是需要更长的时间才能停机而你却等不及。所以，r.e.集在成员资格判定这个问题上，能力是有限的，其根本原因就在于部分可计算函数的“部分”性。

如果$g(x)$是全函数呢？由于$g(x)$是全函数，对于任何一个输入都可以得到结果，因此可以对集合元素加更多限制，得到新的集合类。如果定义可计算谓词$ \chi_{B} (x)$，表示某元素$x$是否属于集合$B$，那么

$$ B=\{x\in \mathbb N | \chi_{B} (x) \} $$

谓词$ \chi_{B} (x)$称为集合$B$的特征函数，若特征函数$ \chi_{B} (x)$可计算，则集合$B$是**递归**的。

从上面的论述就可以感觉到，递归集很可能是递归可枚举集的子类，事实确实如此。如果将递归集看做是二分类之后的r.e.集，就比较容易理解了。因此，

** 定理3.5 递归集必是递归可枚举集。**

既然说到了“二分类”，考虑这个问题：如果一个r.e.集$E$和它的补集$\overline E$都是r.e.集，那么就可以从正反两个方面确定两个集合各自可计算的“领域”，换言之，可以确定某个元素要么在$E$中，要么在$\overline E$中，并没有其他可能。这就相当于构造出了对$E$（或者$\overline E$）的可计算特征函数。因此，结合定理3.5，可以证明，

**定理3.6 集合$E$是递归的，当且仅当$E$和$\overline E$都是递归可枚举的。**

书中通过构造联合计步程序的方式证明了这一定理。不管用什么方法，总觉得这就是排中律的某个具体结论而已。

在GEB中，侯世达用“可以流畅画出”的图形来比喻递归可枚举集。可以流畅画出，意味着这个图形本身是具有某种意义的，但是如果把这个图案从背景上抠掉，那么背景所形成的图案也许就没有任何意义了，这是非常平常的。然而，艾舍尔以它非凡的想象力创造出许多名作，在这些精美的镶嵌画中，不仅前景是有意义可解释的，背景也是有意义可解释的；前景和背景一起，组成了一种宏观的和谐，侯世达将这种和谐称为“倍流畅”的。如果一个图形在它的前景和背景都具有可解释的意义，那么这个图形就是“递归”的。

递归可枚举集合类关于交、并运算是封闭的，这也很容易理解，因为与、或运算都是原始递归的。因此得：

**定理3.7 递归可枚举集合的交集和并集也是递归可枚举集合。**

推广到递归集就是书中的定理3.4了。不同的是，递归集的补集仍是递归集，因为递归集是非黑即白嘛。

那么，递归可枚举集的补集是什么呢？

本节开头就点明了“递归可枚举集就是部分递归函数的定义域”这一事实，并以此引入了r.e.的概念，这也是书中定理5.11明确指出的。根据定理3.2通用性定理，如果将部分可计算函数$g(x)$写成虚拟机在通用机中运行的形式$\Phi (x,p)$，那么集合

$$ W_p = \{ x \in \mathbb N | \Phi (x,p) \downarrow \} $$

显然是递归可枚举集合。并且，由于$p$可以取遍所有自然数，因此可以枚举出所有的$W_p$。这就是：

**定理3.8 枚举定理：集合$B$是递归可枚举的，当且仅当存在$n \in \mathbb N$使得$B=W_n$。**

与停机问题类似，不可计算的问题要远远多于可计算甚至部分可计算的问题，但停机问题是最典型的一个不可计算的问题。为了思考r.e.集的补集的问题，不妨借用停机问题的思路，构造一个集合$K$，它的元素是所有自己在自己的代码上停机的程序代码的集合

$$ K = \{ n\in \mathbb N | n \in W_n \} $$

按照上面给出的$W_n$的定义，也可以写成

$$ K = \{ n\in \mathbb N | \Phi (n,n)\downarrow \} $$

这明显是一个r.e.集。

它的补集$ \overline K $，也就是所有不在自己的代码上停机的程序代码的集合也是r.e.吗？为此，考虑$K$的特征函数，也就是$\mathrm{HALT}(n,n)$，而这个特征函数是不可计算的，也就是说，$K$并非递归集，从而$ \overline K $也不是递归可枚举集。

整个自然数集合是递归可枚举集，因为根据枚举定理，可以写出诸如`(lambda (x) x)`这样的函数，它的定义域是$\mathbb N$。同样的，可以将空集视为递归可枚举集，因为可以写出诸如`(define wtf (lambda (x) (wtf x)))`这样的函数。所以自然数集和空集都是递归集。

在书中5.4节中，给出了这样的结论：如果非空集合$B$是递归可枚举集，那么以下命题等价：

- $B$是部分可计算函数的定义域
- $B$是原始递归函数的值域
- $B$是（部分）可计算函数的值域

> 以上：2017.9.26


#!css

#!js
