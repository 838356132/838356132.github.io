#!metadata
{
    "title":"一条永恒的金带",
    "titleImage":"./image/cover/haruhi-math.jpg",
    "type":"原创",
    "date":"2018-07-10",
    "author":["Mikukonai"],
    "tags":[]
}

#!content

<div style="font-size: 22px;text-align: center; margin:30px 0 30px 0;">前言</div>

当前，以神经网络为代表的连接主义占据了人工智能的上风。但是，在BP算法提出、并使得神经网络真正成为一种堪用的工具之前，符号主义学派才是人工智能的主流。事实上，两千年的逻辑学发展史，就是一部人工智能的探索史。从昔日的机械计算机到今天的数据库、万维网、搜索引擎乃至知识图谱，重视逻辑推理的符号主义智能从来没有缺位，甚至是不可或缺的。

本次培训讲述了人类对于“计算”和“智能”的认识历程，以及在探索“智能”本质之路上，诞生出的最伟大的副产品——计算机——背后的数学原理。在连接主义和机器学习方兴未艾的今天，了解一点逻辑学和符号主义智能的知识，相信可以提升各位同事对于人工智能的“理性”一面的认识，启迪各位从更高的历史和技术站位上，看待我们的技术和产品。

文章末尾列出了大量参考书目，不妨抽出时间读一读，相信会有更大的收获。从某种意义上来说，**本次培训的全部意义和价值，就在于最后的“参考资料”这一章**。

这篇文章是我长期思考和学习的总结，必然存在很多不准确之处。希望各位参加培训的同事批评指正。

<div style="font-size: 22px;text-align: center; margin:30px 0 30px 0;">第一部分 莱布尼茨之梦</div>

在人们的印象中，数学是一门精确无误的学问。但是，在数学的发展历史中，曾经有过三次大的数学危机，直接动摇了数学的根本：

- 第一次数学危机：开辟了算术逻辑化的道路（这条路的前途是光明的吗？）
- 第二次数学危机：奠定了数学分析的坚实基础（真的坚实吗？[Weierstrass function](https://en.wikipedia.org/wiki/Weierstrass_function)）
- 第三次数学危机：开启了互联网时代（但矛盾还是没有解决）

这三次数学危机，都绕不开一个神秘的概念：

: [[#ff0000:**无穷**#]]。

首先，让我们回到公元前六世纪的希腊。

# 1.1 从计算到“计算”

数学有两大任务：**计算**和**证明**。漫长的数学史，某种意义上就是**算术公理化**和**逻辑代数化**的发展史。

古希腊人信奉万事万物都是整数和整数的比，**毕达哥拉斯**（570BC～495BC）学派是他们中的集大成者。然而，毕达哥拉斯的一位弟子发现：**等腰三角形的长边长（例如$ \sqrt 2$），并不能表示为整数之比**。这与毕达哥拉斯学派的信条不合，为了掩盖这件事，此人不幸被扔进大海。

这件事引发了**第一次数学危机**。人们逐渐领悟到，在几何学中，算术和直觉是不可靠的，**只有逻辑才是可靠的**。

------

此后，古希腊的逻辑学开始蓬勃发展。**亚里士多德**（384BC～322BC）提出了**公理化方法**以及著名的**三段论**，这是最早的公理系统，对后世影响极为深远，他的公理化方法，至今仍是初中数学和高中物理最重要的思想。后来的**欧几里得**集古希腊数学之大成，其《几何原本》已成为公理化方法的典范，牛顿的名著《自然哲学的数学原理》即采用《几何原本》的体例。欧几里得的几何学（**欧氏几何**）以有限的几个**公理**或者**公设**出发，通过简单的推理规则，就可以推导出古典几何学的整座大厦。

在欧氏几何的公理中，唯独**平行公理**过于繁琐，不像是基本的公理。证明平行公理的尝试，持续了两千年之久，仍未成功。直到十九世纪，其独立性才被证明。对这个问题的研究，催生了**非欧几何**的诞生，即不承认平行公理的几何学。同时，也带给人们两个重要的启示：

+ 再次确认，几何学中，合乎空间直观并不重要，重要的是**逻辑上的无矛盾性**。
+ “某定理的证明是不可能的”是可以被证明的。

第一点启发后来者，**[[#ff0000:也许可以抽离掉一切依赖于直观的“解释”，将几何学（乃至代数、分析等其他数学）建立在纯粹逻辑之上，成为完全公理化的体系#]]**。第二点启发人们，**[[#ff0000:似乎可以站在某个推理系统之外，去研究系统内部的性质#]]**。

从亚里士多德开始的数学公理化历程，整体上是一条从“计算”走向“推理”的路。然而，十七世纪的一位数学家，正是出于对亚里士多德哲学的深刻理解，他反其道而行之，选择了一条从“推理”走向“计算”的路，梦想**建立一种放之四海而皆准的“通用符号”系统，将“推理”转化为“计算”，从而将一切数学建立在机器运算的基础上**。

这条路比人们想象得要艰苦许多。之所以如此艰苦，是因为在从“推理”走向“计算”的漫长路途中，处处可见神秘而遥远的“无穷”，令人迷惘而绝望。在通向“无穷”的险途中，时常会与**悖论**狭路相逢，绕也绕不开。逻辑代数化之路的艰险，暗示着所谓的“逻辑”很有可能从一开始就是靠不住的。这时，前面说到的第二点给了人们低头看路的超然视角：也许我们可以停下匆匆前进的脚步，认真地思索我们脚下的这条通往终极真理之路——1931年，**哥德尔**终于证明，由于无穷的存在，这条路注定不是人们理想中的完美之路。令人惊叹的是，哥德尔的证明，正是利用了逻辑代数化的最前沿成果——“推理”和“计算”，在哥德尔的证明中实现了完美的统一；两条互为逆向的通向真理之路，在哥德尔的证明中竟然结成了美妙而令人遗憾的环路。在**无穷的循环**中，人们不再执着于“完美”的数学，却脚踏实地地创造了一个更加精彩、更加可爱的全新时代——信息时代。

我们何其幸运，既可以享受信息时代的便利，又可以站在历史长河的下游，尽情地回顾这波澜壮阔的一切。

![艾舍尔《画手》，引自维基百科](https://upload.wikimedia.org/wikipedia/en/b/ba/DrawingHands.jpg)

现在，让我们从十七世纪的这位数学家——**莱布尼茨**（1646～1716）开始，踏上这条永无止境的追寻真理之路。

> 此外，法国数学家笛卡尔和费马各自独立发明了解析几何——即采用计算的方法去研究几何问题。解析几何规避了几何证明对于技巧和创造性的极高要求，将几何证明转化为按部就班的机械的计算。这与逻辑推理的机械化可以说是殊途同归。后文中，我们还将在哥德尔的精巧证明中，见识到将逻辑推理和机械计算结合起来的奇妙力量。

------

# 1.2 符号的力量

各位都知道，莱布尼茨独立于牛顿发明了微积分。我们所熟悉的两个符号：微分号$ \mathrm{d}$和积分号$\int $，都是莱布尼茨发明的，并沿用至今，可见他对于符号的深刻理解。发明微积分，已经是极为伟大的成就，然而他对于逻辑符号化的探索，更是润物无声地开启了逻辑代数化的历程。

莱布尼茨10岁时，第一次接触到亚里士多德的思想，他深受影响。经过长时间的思考，他产生了将“推理”和“计算”合二为一的设想：何不**发明一套“字母表”，其中的字母表示的是“概念”而不是具体的事物，通过[[#ff0000:机械化#]]的符号演算，就可以自动推导出定理**呢？莱布尼茨的高明之处在于，他认识到符号系统对于推理和运算的重大作用。除此之外，**他还意识到了[[#ff0000:二进制#]]与整数和他理想中的计算机器的关系**，这种想法是大大超前于时代的。

他不仅想了，而且做了。1673年，莱布尼茨在伦敦展示了一台能够进行加减乘除四则运算的[计算机模型](https://en.wikipedia.org/wiki/Stepped_reckoner)，他借此当选为伦敦皇家学会会员。

![莱布尼茨的 Stepped reckoner](https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Leibnitzrechenmaschine.jpg/340px-Leibnitzrechenmaschine.jpg)

毕生的工作使他坚定了自己的梦想：

+ 对人类所有知识进行概念化，或者说是符号化；[[#ff0000:（数据库和知识库的雏形）#]]
+ 将逻辑推理转换成对这些符号的“操作”，莱布尼茨称之为“推理演算”。[[#ff0000:（程序语言的雏形）#]]

一言以蔽之：莱布尼茨梦想**[[#ff0000:发明一套符号推理规则，将精巧的逻辑推理转化成机械而严谨的符号变换，从而用机器去代替人进行思考。#]]**这就是莱布尼茨之梦，也是我们的人工智能之梦。

由于时代的局限性，莱布尼茨没有也不可能实现他的梦想。尽管如此，他的思想仍然超前了他的时代一个半世纪，引领着后人在**逻辑符号化、推理自动化**的路上继续前行。沿着莱布尼茨指引的道路，后世的布尔、弗雷格等人，终于开辟出了一条逻辑形式化之路。

------

**乔治·布尔**（1815～1864）出生于英国，但是他对海峡对岸的莱布尼茨的著作特别感兴趣。在仔细研究了亚里士多德和莱布尼茨的著作后，他将前人的思想严格化、形式化，提出了他自己的符号演算体系，也就是著名的**布尔代数**。布尔代数是关于“0”和“1”的代数，但是这里的“0”和“1”并不仅仅是数字意义上的“0”和“1”。**布尔代数的0和1与莱布尼茨的二进制思想在这里达成了微妙的一致**，不得不说是历史的必然。如果将布尔代数解释为对命题的演算，就得到了著名的“**命题逻辑演算**”。

尽管在今天看来，布尔代数是比较弱的代数系统，但已经可以解决许多问题。例如**邮件分类问题**。布尔代数对于计算机体系架构的底层设计，有重要的指导意义。例如，尽管原始的布尔代数需要与、或、非三种运算，但是数字芯片上的逻辑门只需要一种与非门，大大降低了底层硬件的复杂度。此外，几乎所有的编程语言，都将只有true和false的数据类型称为“**Boolean**”型。甚至，还有神学家利用布尔代数去证明上帝的存在。这就是布尔代数的威力。

布尔超越了亚里士多德和莱布尼茨，**[[#ff0000:第一次将他们的设想纳入到一套完善的符号推演系统中#]]**，离莱布尼茨之梦近了一步。更重要的是，布尔代数第一次将计算和逻辑推演结合起来，形成了“逻辑代数”的概念。从此，算术不再是简单的计算，而逻辑也不再是无所寄托的虚幻的东西。**推理与计算、心灵与机械，第一次走得如此之近。**数字电路考场里的考生，对此应该有极其深刻的体会。

但是，布尔代数还不够强大。布尔代数只能处理命题粒度上的演算，而无法处理诸如“所有”、“存在”这样的量词，也无法处理个体的关系和性质（即“谓词”）。1879年，德国数学家**弗雷格**（1848～1925）在《概念文字》一书中提出了一套更加强大的符号演算体系，今天被称为“一阶谓词演算”，是所有学习逻辑学的人必学的内容。

一阶逻辑对于“普通”的数学来说已经完全够用了。弗雷格的工作，为逻辑学提供了一套完善的符号体系。但是，距离莱布尼茨的梦想，仍然有很长的路要走，仍然有很多的坑要补。晚年的弗雷格，在大功告成之时，遭遇了一个足以毁掉他毕生心血的打击。正如弗雷格自己所说：“正当工作就要完成之时，发现大厦的基础已经动摇。对于一个科学家来说，没有什么比这更不幸了。伯特兰·罗素的一封信使我陷入这样的境地。”

究竟是怎样的一封信呢？是什么问题足以动摇弗雷格毕生构建的逻辑大厦呢？下一节，让我们走进“无穷”的世界，一探究竟。

# 1.3 “无穷”的梦魇

## 希尔伯特的旅馆

希尔伯特开了一家旅馆，这个旅馆有可数无穷多个房间，换言之，希尔伯特旅馆的房间数，和自然数的数量一样多。

这天，希尔伯特旅馆来了一个客人，但是很不巧，旅馆已经客满了。正当客人一筹莫展之际，希尔伯特说，别担心，咱们的旅馆有无穷多个房间，我只需要让每个客人都住到他们各自房间号的下一个房间，然后你住在第一个房间就可以了。客人成功入住。

某一天又是客满，此时来了可数无穷多个客人，要求入住。希尔伯特考虑了一下，说，已入住的客人都换到房号乘以2的房间去，这样新来的每个客人就都有房间住了。所有客人成功入住，大家很满意。



## 对角线证明法

对角线证明法是康托尔提出的，用来证明$(0,1)$不可数的一种巧妙的方法。

所谓“可数”，指的是集合中的每个元素都可以与自然数建立**一一对应**的双射关系。假设$(0,1)$可数，那么存在函数$f(i),i\in \mathbb N$与集合中**每一个数**相一一对应。将$(0,1)$内的每一个数都写成十进制的无限小数（有限小数在末尾添加无穷个0，不允许以999...结尾的数字），每个数写一行。以小数的序号为行数，小数的位序号（从0开始）为列数，列出下表：

| |0|1|2|3|4|5|...|
|-----------------|
|0|?| | | | | |...|
|1| |?| | | | |...|
|2| | |?| | | |...|
|3| | | |?| | |...|
|4| | | | |?| |...|
|5| | | | | |?|...|
|...| | | | | ||...|

设$(0,1)$内的某个数$r$的每一位$i$都与$f(i)$的第$i$位（也就是上表对角线上的问号）不等（例如加一，9+1=0），这样$r$仍然是$(0,1)$内的实数，但是与表中每一个$f(i)$都不相等。也就是说，构造出了不在上表中的，然而却真实存在的$(0,1)$内的实数。但根据假设，$f(i)$可以对应所有的实数，这就引起了矛盾。最终得到结论：$(0,1)$不可数。


![逻辑代数化和算术逻辑化，双轨并行](./image/egb/architecture.png)

# 1.4 梦碎、梦醒

## 罗素悖论和《数学原理》

罗素设想了这样一个集合S：**S是由所有不属于自己的集合构成的集合**。

- 如果S属于S：则按照S的定义，S“不属于自己”，所以S不属于S。
- 如果S不属于S：则按照S的定义，因为S不属于自己，因此S应当属于S。

这就推出了明显的悖论：S既属于自己，又不属于自己！

罗素悖论并没有涉及多么高深的数学，矛头直指集合论的核心概念。这个简单的悖论暗示着，集合论的基础，已经变得不牢靠了！

为了消除悖论，将数学建立在严格的逻辑基础上，罗素试图通过给集合乃至一切语言进行“分层”，以破解自指带来的迷惑。他多年的努力和心血，凝聚在一部三卷本的巨著中，这本巨著就是著名的《数学原理》（Principia Mathematica）。

《数学原理》“全面地、系统地总结了自莱布尼茨以来数理逻辑领域的重大成果，奠定了20世纪数理逻辑发展的基础。”此书充满了晦涩难懂的符号推理，导致真正读完这部书的人寥寥无几。事实上，当1930年哥德尔的不完备定理发表之后，就再没有深入研究这部《数学原理》的必要了。尽管如此，《数学原理》仍然是数理逻辑发展史上的一座里程碑。

![是时候展示真正的逻♂辑了<br>引自维基百科](https://upload.wikimedia.org/wikipedia/commons/d/d7/Principia_Mathematica_54-43.png)


## 一致性和完备性

## 数学和元数学

### 红与黑之辩

|[[#ff0000:<span style="font-size: 18px;">黑</span>#]]|<span style="font-size: 18px;">红</span>|
|-----|
|这个字是“黑”字|这个字是“红”字|
|这个字是**[[#ff0000:红#]]**字|这个字是**黑**字|

### 层次问题

（见GEB“消除怪圈”）

## 我们终将知道？

## 哥德尔不完备定理

### 证明奠基：编码与元数学映射

哥德尔证明的核心，是通过构造一个不可证明但却为真的命题$G$，来否定一致PM系统的完备性。$G$的内容是：本命题在PM系统内不可证。

显然，如果$G$可证的话，这就是一个悖论；但如果$G$不可证，那么$G$本身所说的就契合了“不可证”这一事实，从而得到PM中存在不可证的真命题。$G$的奇妙之处在于，它如同一条衔尾蛇，通过自指将处于元PM层次的“可证性”表述，绕进了自身的PM内部的表达形式之中。因此，在构造$G$之前，我们首先要做到两件事情：

- 【元语言符号**形式**的转换】找到一种方法，将元数学关于“可证性”的陈述，表达为PM内部的合式公式（即PM的命题）。
- 【元语言**语义**解释的对应】保证元数学陈述的意义与形式化的PM命题之间的对应，即PM命题可以解释为元数学陈述，同时元数学陈述可形式化为PM中的命题。

如果能够做到这两点，并在PM中构造出$G$，则意味着找到了沟通PM与元PM之间的途径，从而使得PM系统具备了自省的能力。这样，就可以利用PM谈论元PM话题，进而谈论任意深度的“元”PM话题。

![元数学映射机制](./image/egb/meta-map.png)

PM系统自省的核心，便是**哥德尔编码**和**对应引理**。

![PM符号的哥德尔数](./image/egb/godel-number.png)

![哥德尔编码](./image/egb/godel-encoding.png)

哥德尔编码可以将PM公式转化为自然数编码，这样，对于这个自然数编码的数论论述，便等同于对PM命题本身的论述，即元数学论述。而数论论述又是可以被形式化为PM论述的，进而又可以被编码为自然数……这就形成了一个PM——元PM——PM……的循环，加之对应引理赋予PM符号串以元数学的意义，从而使得PM谈论自身成为可能。

为了构造$G$，哥德尔首先将两个元数学表述形式化为PM命题。其中一个用于表达可证性，另外一个用于表达变量代换机制。需要注意的是，下面仅仅说明了这个形式化过程的能行性，但这完全足够了，因为它们的PM符号序列非常非常复杂，写出来也没有太大的意义。此外，这两个形式化过程正是哥德尔证明中大量铺垫的用武之地，距离论证核心稍远，因此也没有必要详细阐明。

从这里开始，必须时刻注意“元数学命题”、“数论命题”和“PM命题”之间的层次和联系。

【第一个元数学话题：$DEM$（证明断言）】

- 元数学命题：哥德尔数为$x$的公式序列$X$，是哥德尔数为$z$的公式$Z$的PM证明
- 数论命题：因比较复杂，简记为$dem(x, z)$
- PM命题：将数论命题翻译为PM命题$Dem(x, z)$

【第二个元数学话题：$SUB$（符号代换）】

将公式$X$的哥德尔数$x$，代入公式自身内部的哥德尔数为$v$的变量$V$，得到的新公式的哥德尔数，记为$sub(x, v, x)$，注意这是数论层面的标记。

举例：

- 公式$(∃x)(x=sy)$的哥德尔数是$m$，则使用$m$这个数在系统内部的写法（$s...s0$，m个s）替换掉$y$得到的
- 公式$(∃x)(x=ss...s0)$的哥德尔数就是$sub(m, [y], m)$
- 与$DEM$类似，$sub$在PM内部的命题可记为$Sub(x, v, x)$

### 证明概览：不可判定的G

+ 在PM系统中构造命题$G$：$P(G)$，其元数学意义为“本命题在PM系统内不可证”。
+ 元数学证明：若PM一致，则$G$不可证。过程如下：
++ 首先证明：$G$可证，当且仅当$～G$可证。
++ 如果$G$和$～G$都可证，则PM不一致。即若PM一致，$G$和$～G$至少有一个不可证。
++ 综合以上两点可得：如果PM一致，则$G$正反均不可证，也就是所谓的“不可判定”。
+ 命题$G$对应的**元数学命题**，在第2步的**元数学论证**中被证明为真，则由对应引理可知，**PM命题$G$**是“真理”。
+ 因此，**PM中存在①不可证的②真命题，也就是说，PM是不完备的！**
+ 进一步地，无论如何扩充PM，都可以构造出类似的$G$。
+ 综合4和5可得：**PM是本质不完备的**。

### 证明细节

【第一步：构造自我指涉的PM命题$G$】

- 构造PM内部公式$G$，对应元数学命题“$G$在PM中不可证”，即“$G$不是PM的定理”。
- 换句话说，“哥德尔数为$g$的公式不是定理”。

- 首先，构造哥德尔数为$n$的公式$\gamma := ～(∃x)Dem(x, Sub(\mathrm Y, 17, \mathrm Y))$，其中$\mathrm Y$是一个“元”PM符号，可视为可以替换成其他合式PM公式的“占位符”。
- 将哥德尔数$n$对应的PM数字表示形式$N$<sup>[注]</sup>，代入上式$\gamma$中的$\mathrm Y$，得到公式$\Gamma := ～(∃x)Dem(x, Sub(N, 17, N))$
- 如何理解PM公式$\gamma$和$\Gamma$的关系呢？事实上$\gamma$**并不是一个确定的公式**，因为其中有个“变量”$\mathrm Y$，它的哥德尔数$n$实际上也是不确定的。我们不妨把$\gamma$看成是一个“公式方程”。而$\Gamma$是什么呢？$\Gamma$是一个**确定**的PM公式，它的哥德尔数是确定的数$n$，对应确定的PM表示形式$N$，它的PM公式形式也不含有任何不确定的部分。因为$N$和$n$是同一个数字的不同表示形式，而根据$\Gamma$的特点，$N$的形式决定了$n$的取值，也就是说，$\Gamma$通过哥德尔数进行了**自我指涉**。
- 回想$\Gamma$的构造过程：将$\Gamma$自身的哥德尔数$N$代入$\gamma$自身的变量$\mathrm Y$中，就得到$\Gamma$。也就是说，$\Gamma$是“公式方程”$\mathrm Y = \mathrm{PM\_WFF\_of\_Godel\_Number\_of}(\gamma(\mathrm Y))$的一个解。

- 依据对应引理，PM公式$\Gamma := ～(∃x)Dem(x, Sub(N, 17, N))$的元数学意义是：“哥德尔数为$sub(n, 17, n)$的PM公式是PM内不可证的。”注意这句话里面的符号都是小写的，也就是以数论的语言，表达了这个元数学命题。
- 这个元数学意义，恰好是我们最初打算构造的PM公式$G$，所表达的元数学意义。
- 也就是说，**PM公式$\Gamma := ～(∃x)Dem(x, Sub(N, 17, N))$就是我们所需要的$G$。**

- PM公式$G$的哥德尔数$g=n$恰好是PM公式$G$对应的数论命题$～(∃x)dem(x, sub(N, 17, N))$的一部分！
- 也就是说，构造了这样的一个对应的元数学诠释：
- “‘哥德尔数为$g$的公式是不可证的’这个公式是不可证的”
- 总之，的确可以构造出PM公式G，它说它自己不是PM的定理。

> 注：“$n$对应的PM数字表示形式”，指的是在PM系统中，用于表示数$n$的合式公式$N$，即形如“ss..s0”这样的字符串。这里一定要理解，数和用于表示数字的公式，是不同语言层面上言说的东西。

!["G"这个字母也很像衔尾蛇](./image/egb/ouroboros.png)

【第二步：$G$在一致的PM系统中是不可判定的】

- 可以证明：“$G$是可证的，当且仅当$～G$是可证的”。<sup>[注]</sup>
- 如果PM系统内部可以证明两个互相矛盾的命题，说明PM是不一致的。也就是说，若PM是一致的，则$G$和$～G$至少有一个不可证。
- 结合上面两点，$G$和$～G$都不可证。
- 因而，**若PM一致，则必然存在一个公式$G$，使得$G$和$～G$都不可证，即“形式上不可判定”**

> 注：哥德尔证明的是：若$G$可证，则$～G$可证（意味着PM不一致）；而若$～G$可证，则PM是ω-不一致的。

> 所谓的ω-不一致指的是：现有形式系统$C$，若其公式$(\exists x)P(x)$和无穷多个公式$～P(0)$、$～P(s0)$、$～P(ss0)$、……都是可证的，则$C$是ω-不一致的。

【第三步：$G$是元数学层面上的“真理”】

- 哥德尔说明，尽管$G$是PM不可判定的，但$G$在元数学意义/算术意义上是真的。
- 因为$G$的元数学意义是“某个命题自身是PM不可证的”，其算术意义是“并不存在一个数，满足这个数自身对应的某种性质”。
- 而我们刚刚（第二步）就**在元数学层面上**，证明了“$G$是PM不可判定的”**也即$G$本身所言说的**。
- 第二步的对$G$的不可判定性的元数学证明，实际上构成了对$G$的元数学真理性的证明。
- 综上，$G$在元数学层面上是真的。

【第四步：由于$G$的存在，PM是不完备的】

- “不完备”的意思是：存在系统内部不可形式判定的真命题。
- 在一致的前提下，存在PM命题$G$（第一步），它既是不可判定的（第二步），又是“真的”（第三步），所以PM必然是不完备的。

【第五步：还可以抢救一下吗？放弃治疗吧】

- 如果把刚刚找到的$G$作为公理，给PM打补丁呢？
- 然而，即便在PM中添加新的公理，使PM更强，但按照上面的套路，
- 总可以类似地找到另外一个$G'$，它是在“增强PM系统”中不可判定的真命题。
- 无论如何增强这个系统，都无法逃脱这个本质上的限制。
- 也就是说，**PM在本质上是不完备的。**

至此，我们得到了著名的哥德尔第一不完备定理：PM系统是不完备的。

### 一致性不可自证

PM足够强大到证明自身的一致性吗？很遗憾，不可能。请看证明：

- 构造PM公式$A→G$，其中$A$表达的元数学命题是“PM是一致的”，
- 并证明$A→G$在PM中可证。
- 假设$A$在PM中可证（也就是PM自身可以证明自身的一致性），
- 则根据分离规则，$G$也应该是可证的。
- 然而刚才已经证明，如果$G$可证，则$～G$可证，意味着PM不一致，矛盾。
- 因此，**如果PM一致，则PM不可能证明自身的一致性。**

这就是哥德尔第二不完备定理。

但请注意，哥德尔的证明**并未排除在PM系统外证明PM一致性的可能性！**

## 向创造思维致敬

> 演算机械的固有局限性并不意味着不能用物理学或者化学的方法来解释生命和理性。哥德尔定理既没有排除、也没有肯定这种可能性。哥德尔定理的确表明，**人类思想的结构和力量，要远比任何机器都要复杂和微妙。**哥德尔证明本身，便是这种**复杂**和微妙的显著例证。**我们完全不必为此失望，而应把握住这个对创造性理性再次赞赏的机会。**

> ——《哥德尔证明》第八章：结论性的反思

哥德尔证明→编码与计算→计算的极限→在微妙的复杂中超越计算极限

![“愚者”千反田酱，象征着无限的可能](./image/egb/chitanda.jpg)

<div style="font-size: 22px;text-align: center; margin:30px 0 30px 0;">第二部分 编码的奥秘</div>

# 2.1 丘奇和图灵


## 图灵机


## λ演算

[λ演算](https://en.wikipedia.org/wiki/Lambda_calculus_definition)是丘奇设计的一套抽象的符号演算系统，是Lisp、Common Lisp、Scheme、Racket、Haskell、Clojure等函数式编程语言的理论基础。

后文中，我们将采用Scheme风格的语法，来向大家介绍λ演算的基本规则。相比我们平时使用的Python和Java，λ演算非常简单，它只有一个关键字“lambda”。λ演算的基本语法元素是“项”（term），项只有三种：

- **符号**：任何有效的名字；
- **函数**：(**lambda** (*symbol*...) *term*)
- **调用**：(*term*...)

以下几个λ表达式都是合法的λ表达式：

```:lisp
1 (a b)
2 (a (lambda (x) x)) ;函数作为参数
3 (lambda (x) x)     ;符号作为返回值
4 (lambda (x) (lambda (y) x) )    ;函数作为返回值
5 ((lambda (x) (lambda (y) x)) 2) ;调用
```

λ演算同样有“作用域”的问题。实际上，所谓的作用域问题，可以追溯到弗雷格的一阶谓词演算，并不是设计编程语言的人拍脑袋想出来的东西，而是有着深刻的数理逻辑背景。在λ演算中，**自由变量**指在函数体中出现，但是没有在本级函数参数列表中出现的符号。例如上面例4中内层函数的x。**约束变量**指的是在函数体中出现，且在本级函数参数列表中出现的符号。

约束变量可以视为“形式参数”，而自由变量可以视为C语言中的全局变量，或者是Java的类静态变量。关于自由变量和约束变量的处理方法，我们将在2.3节的“环境和闭包”中详细讨论。

演算规则只有简单的三条：

- **α-变换**：`(λ (a) [a]) = (λ (b) [b])`
- **β-归约**：`[(λ (x) (f x)) 喵] = (f 喵)`
- **η-变换**：`f := (λ (x) (f x))`

其中，β-归约是核心规则，它形式化地描述了所谓“函数调用”的本质——约束变量代换。而α-变换揭示了一个普遍的现象——形式参数的名称是不重要的。在JavaScript等语言中，甚至不需要显式地声明函数列表，而直接用arg[n]代表第n个形式参数；在Java中，也常见arg0、arg1这样的说法，其背后的原理，就是这条“α-变换”。

尽管λ演算看起来非常简单，但是它的能力非常强大。这里，我们先不讨论λ演算的威力，而是通过一个非常简单的例子，引出我们即将讨论的问题。

<code id="scheme1" style="display:none;">(display ((lambda (a b) (/ (+ a b) 2)) 100 200))</code>

> **示例1**：计算两个数的平均数

```:lisp
( (lambda (a b) (/ (+ a b) 2))
  100
  200 )
```
> : <button id="js00" onclick="try{alert(mrRun(getCode('scheme1')));}catch(err){alert(err);}" class="md-button">执行</button>

简单的示例1，就可以说明许多深刻的问题：

+ 在λ演算中，算术表达式都是[前缀表达式](https://en.wikipedia.org/wiki/Polish_notation)。前缀表达式的好处在于：其一：可以不对运算符的“目数”加以限制，后面可以跟一个甚至多于两个操作数。其二：运算符在前缀式中更能凸显其“函数”本质，而无需C++那丑陋而复杂的“运算符重载”机制。其三：前缀式实际上就是AST的线性表达，相比于中缀式，可以表达出所有中缀式所隐含的东西（例如“运算符优先级”等等）。**关于AST及其解析、计算的规则，我们将在2.3节中详细讨论。**
+ 作为可以实际执行的程序，而不仅仅是在纸面上抽象的符号推导，我们必须事先规定几个“基本（**primitive**）符号”或者“基本操作”。例如上例中的加号、除号，其实都是在λ演算之外定义的（JavaScript）。加号和除号，就是我们在讨论哥德尔证明时强调过的“**元语言**”层面的东西。在我们熟悉的Java中，就是native的概念。native，就是“元语言”层面上的程序了。
+ 根据三条演算规则，以及元语言层面上的规则，我们就可以在元语言层面上对λ表达式进行**求值**。翻译成我们熟悉的语言就是：根据Java语言本身的语法规则，以及JRE和第三方Jar包提供的各种功能，我们就可以在JVM的层面上，执行Java程序，在控制台上打印出结果。**关于这一点，我们将在2.4节中详细讨论。**
+ 那么，不考虑奇奇怪怪的[副作用](https://en.wikipedia.org/wiki/Side_effect_(computer_science\))，常见的四则运算，能否在λ演算的内部定义出来呢？之所以提这个问题，是因为在编程语言中，衡量一门语言的成熟程度，就看它的标准库是不是用自己写出来的。尽管从效率等实际的工程因素来考虑，一般是使用C甚至是汇编去写底层库，但这里我们关心的是：如此简单甚至简陋的λ演算，能否在自身内部定义一些基本的运算呢？**2.2节，我们将深入讨论这个问题，并带你逐步领略λ演算的巨大潜力。**





# 2.2 我想给你“整”个世界

在第一章中，我们讲述了莱布尼茨的梦想，也就是发明一种通用的语言，用来表达世间所有的知识，当然也包括数学。在这一节中，我们尝试利用λ演算，从“一无所有”开始，构造“0”和“1”，构造加减乘除，一步一步地构造一个通向无穷的虚拟世界。





+ 皮亚诺算术和Church-encoding（先导出自然数加法、减法（[monus](https://en.wikipedia.org/wiki/Monus)），以及布尔代数）
+ 通过除法/求余，引出匿名函数递归的问题。这里留下悬念，为第三章做铺垫。
+ 总结下来就是，λ演算就是哥德尔证明中涉及的“数论系统”，为第三章最后讲停机问题做铺垫。

<code id="scheme2" style="display:none;">  (define SHOWNUM  (lambda (n)  (display (n (lambda (x) (+ x 1)) 0))))  (define SHOWBOOL  (lambda (b)  (display (b true false))))  (define $true  (lambda (x y) x))  (define $false (lambda (x y) y))  (define $0 (lambda (f a) a))  (define $1 (lambda (f a) (f a)))  (define $2 (lambda (f a) (f (f a))))  (define $3 (lambda (f a) (f (f (f a)))))  (define $4 (lambda (f a) (f (f (f (f a))))))  (define $5 (lambda (f a) (f (f (f (f (f a)))))))  (define $6 (lambda (f a) (f (f (f (f (f (f a))))))))  (define $7 (lambda (f a) (f (f (f (f (f (f (f a)))))))))  (define $8 (lambda (f a) (f (f (f (f (f (f (f (f a))))))))))  (define $9 (lambda (f a) (f (f (f (f (f (f (f (f (f a)))))))))))  (define $10 (lambda (f a) (f (f (f (f (f (f (f (f (f (f a))))))))))))  (define $11 (lambda (f a) (f (f (f (f (f (f (f (f (f (f (f a)))))))))))))  (define $12 (lambda (f a) (f (f (f (f (f (f (f (f (f (f (f (f a))))))))))))))  (define $13 (lambda (f a) (f (f (f (f (f (f (f (f (f (f (f (f (f a)))))))))))))))  (define NOT  (lambda (bool)  (bool $false $true)))  (define AND  (lambda (boolx booly)  (boolx booly boolx)))  (define OR  (lambda (boolx booly)  (boolx boolx booly)))  (define IS_ZERO  (lambda (n)  (n (lambda (x) $false) $true)))  (define IF  (lambda (p x y)  (p x y)))  (define INC  (lambda (n)  (lambda (f a)  (f (n f a)))))  (define ADD  (lambda (m n)  (m INC n)))  (define PAIR  (lambda (x y)  (lambda (f)  (f x y))))  (define LEFT  (lambda (pair)  (pair $true)))  (define RIGHT  (lambda (pair)  (pair $false)))  (define SLIDE  (lambda (pair)  (PAIR (RIGHT pair) (INC (RIGHT pair)))))  (define DEC  (lambda (n)  (LEFT (n SLIDE (PAIR $0 $0)))))  (define SUB  (lambda (m n)  (n DEC m)))  (define IS_LE  (lambda (num1 num2)  (IS_ZERO (SUB num1 num2))))  (define IS_EQUAL  (lambda (num1 num2)  (AND (IS_LE num1 num2) (IS_LE num2 num1))))  (define Y  (lambda (S)  ( (lambda (x) (S (lambda (y) ((x x) y))))  (lambda (x) (S (lambda (y) ((x x) y)))))))  (define Fib  (lambda (num)  ((Y (lambda (f)  (lambda (n)  (IF (OR (IS_EQUAL n $0) (IS_EQUAL n $1))  $1  (lambda (x y) ((ADD (f (SUB n $1)) (f (SUB n $2))) x y))  )))) num)))  (SHOWNUM (Fib $0))  (newline)  (SHOWNUM (Fib $1))  (newline)  (SHOWNUM (Fib $2))  (newline)  (SHOWNUM (Fib $3))  (newline)  (SHOWNUM (Fib $4))  (newline)  (SHOWNUM (Fib $5))  </code>

> **示例**：从“无”到无穷

```:lisp
;; 元语言
(define SHOWNUM (lambda (n) (display (n (lambda (x) (+ x 1)) 0))))
(define SHOWBOOL (lambda (b) (display (b true false))))

;; 基本元素
(define $true  (lambda (x y) x))
(define $false (lambda (x y) y))

(define $0 (lambda (f a) a))
(define $1 (lambda (f a) (f a)))
(define $2 (lambda (f a) (f (f a))))

;; 布尔代数
(define NOT (lambda (bool) (bool $false $true)))
(define AND (lambda (boolx booly) (boolx booly boolx)))
(define OR (lambda (boolx booly) (boolx boolx booly)))
(define IS_ZERO (lambda (n) (n (lambda (x) $false) $true)))
(define IF (lambda (p x y) (p x y)))

;; 自然数
(define INC (lambda (n) (lambda (f a) (f (n f a)))))
(define ADD (lambda (m n) (m INC n)))

(define PAIR (lambda (x y) (lambda (f) (f x y))))
(define LEFT (lambda (pair) (pair $true)))
(define RIGHT (lambda (pair) (pair $false)))

(define SLIDE (lambda (pair) (PAIR (RIGHT pair) (INC (RIGHT pair)))))

(define DEC (lambda (n) (LEFT (n SLIDE (PAIR $0 $0)))))
(define SUB (lambda (m n) (n DEC m)))

(define IS_LE (lambda (num1 num2) (IS_ZERO (SUB num1 num2))))
(define IS_EQUAL (lambda (num1 num2) (AND (IS_LE num1 num2) (IS_LE num2 num1))))

;; Y组合子
(define Y
  (lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y)))))))

;; 斐波那契数
(define Fib
  (lambda (num)
    ((Y (lambda (f)
          (lambda (n)
            (IF (OR (IS_EQUAL n $0) (IS_EQUAL n $1))
                $1
                (lambda (x y) ((ADD (f (SUB n $1)) (f (SUB n $2))) x y)))))) num)))
```
> : <button id="js00" onclick="try{alert(mrRun(getCode('scheme2')));}catch(err){alert(err);}" class="md-button">执行</button>

本节讲述的系统，就是丘奇提出的用以编码整个数学的方案——[Church-encoding](https://en.wikipedia.org/wiki/Church_encoding)。我是在读《计算的本质》这本书时，第一次接触到Church-encoding的。读到这里时，Church-encoding体现的从一无所有构造一切的结构美和体系美，令我深受震撼，终于明白为什么有那么多的人沉浸在枯燥的符号演算中无法自拔。一旦你真正见识过这种“万丈高楼平地起”的精妙和恢弘，相信你也会陶醉其中。这就是我专门以一节的内容讲述Church-encoding的原因——我想给你“整”个世界。

# 2.3 从语法到语义

+ 语法树AST和数据结构
+ 程序的语义由解释器赋予
+ 求值顺序：积极求值和惰性求值
+ 约束变量和自由变量：闭包、环境和作用域

让我们从抽象的形式系统回到具体的编程语言。本节讲述三个问题，这三个问题是所有编程语言共通的问题。理解了这三个问题，以后我们再学习新的语言时，就很容易抓住语言细节背后的本质了。

## 抽象语法树（AST）

不论一门编程语言的语法有多复杂，在分析的时候都是被转化成树状结构进行分析的。**抽象语法树**（AST）就是源代码在编译器/解释器中的表现形式。

与具体语法树不同，AST体现的是代码的逻辑结构。绝大多数编程语言的语法采用的都是上下文无关文法，但是根据语言的特性不同，它们采用的具体的语法也不同，前端分析的时候会生成不同的“具体语法树”。有的编译器，例如gcc，支持多种语言，不同的语言，语法当然是不一样的。但是，有些东西，比如说循环结构，在逻辑上是共通的。不管前端支持何种语言、何种语法、何种分析方式，循环的**逻辑结构**没有变。如何理解这一点呢？我们来看下面两段代码：

```:C
// Java
for(int i = 0; i < 10; i++) {
    sum += i;
}

// Python
for i in range(10):
    sum = sum + i
```

尽管写法大相径庭，但是它们的AST都可以写成同样的形式。这就是AST之所以成为“抽象”语法树的原因。

AST的价值是显而易见的。AST首先将代码的逻辑结构与语法细节剥离开来，为后端的分析、优化、代码生成提供了统一的标准。后端不需要关心前端是LL(1)还是LR(1)，甚至不需要关心前端翻译的是什么语言。这是典型的[[#ff0000:**封装**#]]思想。

那么，作为语言使用者，我们为什么要了解AST呢？

- 静态复杂度分析。我们常用的静态分析工具，其前端所做的工作之一就是将代码翻译成AST。实际上，我们自己在判断代码复杂度的时候，实际上已经在脑中构造了一棵AST——只不过是因为缩进和括号的存在让这颗AST变得相当明显了而已。
- 认识到代码结构和数据结构的奇妙的一致性。AST是树状结构，因此我们处理树状数据结构的时候，就可以利用这种同构性。一个非常典型的例子就是二叉树的遍历：

```:C
class BTree {
    element node;
    BTree left;
    BTree right;
}

traverse(tree) {
    ...
    travarse(tree.node);
    traverse(tree.left);
    traverse(tree.right);
}
```

数据本身的结构和`traverse`的结构竟然达成了惊人的一致！利用这种同构特性，我们就不需要显式地维护栈和状态，而可以像上面一样，直接利用语言提供的递归机制就可以实现这个函数了。反过来讲，对于一个函数调用，例如`(+ (* 3 3) (* 4 4))`，对它的求值过程，实际上就是对这棵AST进行遍历的过程。这个例子进一步给了我们两点启示：

+ 数据和代码可以同构，实际上它们是同一个东西：代码即数据。对现在的我们来讲，这个观点已经不新鲜了。
+ 递归是一个很厉害的东西，不仅可以递归地定义数据结构，并且可以递归地处理数据结构。我们在这里又遇到了递归。

## 求值顺序

在上面的二叉树遍历中，程序按顺序递归地遍历了根节点、左子树和右子树，这称为二叉树的先序遍历。之所以是按照这个顺序，是因为我们按照node、left、right的顺序排列代码。这种从上到下依次执行的顺序，实际上就是一种**隐含的**求值顺序约定，这种约定称为编程语言的[求值策略](https://en.wikipedia.org/wiki/Evaluation_strategy)。下面，针对我们在实际工作中可能会遇到的问题，讲几种常见的求值策略，以及它们的应用场景。

- **严格求值**。也叫积极求值。所谓的严格求值，指的是只要在代码中出现，就立即求值得到结果，再进行后续求值。例如：对于这个表达式`(f (g 1) (h 2))`，在求值整个表达式的时候，如果按照严格求值顺序，就会先按顺序求值`(g 1)`和`(h 2)`这两个**出现在参数上的表达式**，等得到值以后，才计算`f`。我们常用的Java和Python都是严格求值的，也是命令式语言最常用的求值顺序。
- **惰性求值**。在某些情况下，例如处理**递推数据结构和递归过程**的问题时，严格求值往往会造成无穷递归。为了聚焦惰性求值主题，我们直接从阶乘的例子出发，说明这种见得不多但是实际上很有用的求值策略。在下面的例子中，尽管例子都是用Python写的，但是执行效果都是用等价的JavaScript实现的。这再次证明，函数式方法是一种超脱于具体语言的方法。

**[[#0000ff:Python的推导式和生成器#]]**。推导式和生成器都是非常函数式的写法，不仅Python有这样的机制，许多高级编程语言（如JS、C#）都有类似的机制，只是叫法不同。Google做的“MapReduce”大家可能都有所耳闻，可见，如果底层有充分的优化，函数式编程对集合操作的封装，不仅减轻了程序员手写迭代的负担，让程序员在更高层次的抽象上思考问题，还可以给底层工程师以充分的优化大规模数据处理性能的空间。

我们知道，阶乘是典型的递归定义的过程。利用生成器，我们可以以正常的递归写法表示阶乘，同时可以把它当作一个“可迭代的”（iterable）对象，像列表一样在循环中使用。这样做有许多好处：其一，生成器并非递归函数，因此计算每个值的时候就不需要从n!一直计算到0!，换句话说就是，**[[#ff0000:生成器将递归化为了迭代#]]**。其二，生成器体现出典型的“惰性”特性，即，在使用上，生成器像是一个数组，而实际上，**[[#ff0000:里面的元素都是在需要时才被计算出来的#]]**。这两种特性，使得生成器特别适合于处理无限递推的数据结构。这一思想，实际上呼应了我们在第一章提到的“潜无穷”观念。

> 生成器：可迭代的阶乘“函数”

```
def fac():
    n = 1
    product = 1
    while True:
        yield product
        product = product * n
        n = n + 1

for i in fac():
    print(i)
```

> : <button id="js00" onclick="function\* fac(){let n = 1;let p = 1;while(true) {yield p;p = p * n;n++;}} let a = fac(); let s = a.next().value+'\n'; s += a.next().value+'\n'; s += a.next().value+'\n'; s += a.next().value+'\n'; s += a.next().value+'\n'; s += a.next().value+'\n'; alert(s);" class="md-button">执行</button>


生成器涉及到程序上下文的保存、控制流跳转等诸多问题，这些问题的背后有着深厚的逻辑学背景，生成器只是将它们封装起来而已。限于篇幅和我的水平，这里就不展开了，欢迎各位指教和讨论。关于上下文的问题，这是下节要说明的内容。

此外，如果把`if`这样的条件分支结构也视为函数，那么`if`也是一个典型的采取懒惰求值策略的函数。因为if的两个分支中有且只有一个分支可能被执行（求值），这取决于条件表达式的真值。一个非常典型的例子是SICP的习题1.6，感兴趣的同事不妨看看。

- **短路求值**。在布尔表达式中，短路求值可以提高效率。利用这一点，日常工作中，我们也应当尽量恰当地设计条件判断，使得“与”式中可能取假值的项放在前面，“或”式中可能取真值的项放在前面。可见，短路求值也是一种广义上的懒惰求值策略。
- **其他特殊求值顺序**，请感兴趣的同事进一步阅读：[求值策略](https://en.wikipedia.org/wiki/Evaluation_strategy)

## 环境和闭包

作用域问题，是我们学习一门新语言时首先关注的问题之一。在C这样的简单语言中，有形参作用域、块作用域、全局作用域等多种作用域规则；在Java这样的复杂的OO语言中，作用域问题不仅体现在语言语法层面，还体现在OO规定的逻辑层面上。诸如private/protected/public的区别，以及诡异如C++的友元、虚函数、动态绑定等概念，其实都可以归结到作用域的问题。让我们从“动态绑定”和“闭包”这两个让初学者难以理解的概念开始，谈谈编程语言的**作用域策略**。

一般而言，作用域策略有两种：**[[#ff0000:静态作用域#]]**和**[[#ff0000:动态作用域#]]**（Dynamic scoping），其中静态作用域又叫**[[#ff0000:词法作用域#]]**（Lexical scoping）。在2.1节中，我们引出了“自由变量”的概念，实际上，作用域策略可以说就是处理自由变量的策略。我们首先来看日常工作中用得较多的动态绑定，和作用域策略有什么关系。

动态绑定，又叫“多态”，指的是在涉及继承的OO程序中，根据执行时“环境”来判断对象类型的机制。例如：

```
class Animal {
    cry() { print('哼唧'); }
    fly() {...}
}
class Cat extends Animal {
    cry() { print('喵~'); }
}

main() {
    Animal tom = new Cat();
    tom.cry();    // 喵~
}
```

谈论多态，必然要区分**编译时**和**运行时**。编译时，根据前三行的声明，编译器可以确认，tom这个Animal类型的对象对cry函数的引用是合法的，同时建立cry符号到Animal类的cry方法的字节码的“绑定”，此时并不能确定这个cry是子类的cry()方法，因为还没有执行Cat的构造函数，也就是说，只能在语法的层面上确保类型安全。运行时，JVM会先建立son对象，并将其压入操作数栈，随后通过VM指令`invokevirtual`，按照栈中实例的实际类型，调用cry()方法。如果这里调用了Cat中没有的方法，而Animal中存在的方法，比如`fly()`，则会递归地向上查找父类方法。

透过复杂的实现细节，我们可以总结出一点，那就是：在语法层面上完全相同的符号`cry`，其绑定的实际值（方法字节码位置），是与其所在环境（实例类型）有关的。同样是cry方法被调用，实际执行的函数却完全不同，这就是“动态作用域”。

C语言中，作用域策略相对简单，不过仍然有块作用域、全局作用域等概念。这些作用域是“静态作用域”，也就是符号的绑定关系在编译期就可以被确定。在静态作用域策略下，同名的符号，在不同的环境被引用，也不会受到所在环境的干扰，而是使用其AST层次上的绑定。静态作用域今天看似自然且合理，但实际上在Emacs Lisp等早期的Lisp方言中，设计者并没有意识到将定义环境与运行环境分开解释，事实上使用了充满歧义的动态作用域机制。（[来源](http://www.yinwang.org/blog-cn/2012/08/01/interpreter)）后来，绝大多数语言都采用了更加严谨、易于分析的静态作用域策略。现在，在完善的OO机制的保证下，动态绑定本身已经成了一种非常灵活好用的机制，但，仍然容易令初学者迷惑（滑稽

------

动态作用域与“**环境**”（environment）是息息相关的。所谓的“环境”，指的是一种抽象的东西，里面保存了一段程序的**上下文**（context），以及程序运行所需的符号的具体绑定。

环境是语言的背景知识，是语言创造出的虚拟空间。说到环境，就不得不提一个更加令人费解的概念——**闭包**（closure）。

闭包原本是关系代数的概念，但如今在编程领域用得较多。所谓的闭包，用最简短的语言解释，就是含有自由变量及其引用的程序。闭包的例子随处可见，例如，上一节中说到的tom对象，实际上就是一个闭包，它保存了外部定义符号`cry`对于自身才有效的引用（指向Cat类cry方法的字节码地址）。还有，前面我们说到的阶乘生成器，实际上也是一个闭包。它的内部除了保存了`n`、`product`等变量的实际值之外，还保存了程序运行的位置。另外，在Java等过程式语言的函数调用中，调用栈栈帧也可以视为一个闭包，只不过对于C这样的语言来说，因为没有动态作用域，所以闭包体现得不明显而已。**闭包就像是程序运行中创建出来的平行时空，自由变量就是这些平行时空之间的虫洞。**

可见，闭包也是一个脱离具体语言的通用概念。闭包中保存了自由变量，而对自由变量的解引用涉及到其值的来源问题。现在，我们可以用闭包的说法来解释两种作用域策略了：凡是以闭包内部为优先的作用域，就是动态作用域，因为闭包是动态的。而以AST为优先的作用域，就是静态作用域。当然，有可能出现AST与闭包层次一致的情况，这就涉及到我们下一章要讲到的**匿名函数**了。

------

本节讲AST、讲求值策略、讲作用域策略，目的是为了让各位站在更高的层次上看待各种语言的抽象机制和执行机制，避免陷入语法细节的泥潭里面去（比如说谭老师的++i++++i这种）。这样，快速入门一门新语言，就不是什么难事了。

# 2.4 通用机器

在计算机的世界中，最令人惊叹的就是无处不在的递归、分形和自相似性。上文中，从哥德尔对元数学的编码，到程序与数据结构的奇妙同构，再到层层嵌套的闭包和作用域，都显示出了这种让人眼花缭乱的美感。这些奇妙的自相似现象的背后，是图灵机及其等价模型最强大的一个性质——通用性。

## 层层嵌套的虚拟世界

所谓图灵机的通用性，指的是**[[#ff0000:可以构造一个通用图灵机（UTM），它可以模拟出包括通用机在内的任何一台图灵机的行为#]]**。如何理解这句话呢？

至今为止，我们写出的每一段程序，都对应一部图灵机，都只能完成某一个特定的任务。通用性定理告诉我们，可以写出一台**[[#ff0000:可编程#]]**的机器，它可以“运行”其他的图灵机，完成其他图灵机的任务。进一步说，我们可以写出足够强大的通用图灵机，在它的上面可以运行另外一个通用图灵机……如此嵌套，理论上可以嵌套无穷层。

是不是很熟悉？没错，实际机器中，不同结构层次的UTM，有不同的名字：**解释器**、**虚拟机**、**指令集**，等等。尽管每一层的任务都不同，但是在理论上，每一层都是通用的。

------

编程语言可以分为编译型语言和解释型语言。编译型语言是将源代码编译到机器码，在指令集和操作系统层次上执行；而解释性语言，一般需要一个运行环境，称为解释器或者虚拟机。例如，JVM就是运行Java字节码的虚拟机；Python既可以直接解释执行，也可以编译为字节码在机器上执行。无论是在VM上执行，还是在指令集上执行，最终都要归结到指令集层次上的动作。

通用性定理带给我们的另一个重要启示是：**[[#ff0000:程序代码本身，也可以作为输入程序的数据#]]**。这一点，其实是非常自然的，也就是“解释器本身就是解释程序的程序”，JVM本质上也只不过是磁盘上的一个文件而已。许多高级语言，也提供了各种机制，帮助我们站在数据的角度上，去看待和操纵数据。例如，C++的模板和泛型、Java的反射、函数式语言的一等函数、Ruby强大的元编程等等。这些技术，都可以统称为“元编程”，即使用代码操纵代码的编程。

许多语言也提供了运行时解释/编译的能力，名字可能叫做“动态编译”等等。总而言之，这类机制一般会提供一个诸如JS的`eval(code)`的接口，可以在运行时执行代码。对于一般的开发者而言，程序的功能是明确而有限的，一般不需要这些动态执行接口。但是，在某些场景下，例如手机App热更新代码还有某些计算机病毒，这些场景下就必须将数据作为代码，并在运行时动态地执行。这种动态执行的功能是极其强大，同时又极端危险的，所以各大平台一般都会封堵掉编程语言提供的这类接口，例如微信小程序就封堵了JavaScript的`eval`函数和`Function`类，避免开发者热更新内部代码。但是根据通用性定理，只要平台提供的语言是本身图灵完备的，理论上就可以手工写出`eval()`函数，相信鹅厂的工程师也明白这一点。在杀毒软件、iOS和现代浏览器中，普遍使用的“沙箱”，实际上就是一个UTM，它模拟出一个虚拟的但是与物理机完全隔离的世界，而这个世界实际上是运行在物理机这个UTM上面的，只不过它们中间还有一道关口，用来隔离二者。这种“隔离”，只要明白了我们上一节讨论的“闭包”和“作用域”思想，就很容易理解了。

## 冯·诺伊曼模型

天才的计算机科学家**冯·诺伊曼**（1903~1957）是一位全才，他不仅在数学上造诣深厚，还是一位优秀的工程师，曾参与曼哈顿计划，以及第一台存储程序结构的计算机——[EDVAC](https://en.wikipedia.org/wiki/EDVAC)（电子离散变量自动计算机）的设计。众所周知的第一台电子计算机——ENIAC，每秒能做5000次加法，在当时已经是划时代的速度。但是，ENIAC采用十进制运算，并且其“编程”需要手工改变计算机内部的接线方式，非常耗时耗力。而EDVAC采用存储程序设计，也就是今天几乎所有计算机共同采用的**冯·诺依曼架构**，这种设计将程序作为数据的一部分，存储在存储器中，程序运行的时候再取出。并且，冯·诺伊曼考虑到电子器件的双稳特性，第一次在计算机中使用了二进制。如今，尽管计算机在性能上取得了堪称爆炸的进步，但是其基本架构，仍然逃不掉冯·诺依曼的存储程序模型。

![冯·诺伊曼架构](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/510px-Von_Neumann_Architecture.svg.png)

在第四章，我们会简单探讨摆脱冯氏架构的可能性。当然，摆脱冯氏架构，某种程度上就意味着放弃了图灵机。你可能会问，图灵机如此强大，为什么要摆脱图灵机？并且，不使用图灵机，我们的人工智能之路，还有别的入口可走吗？那么，在摆脱图灵机之前，我们先看看，图灵机究竟有没有什么缺陷。


<div style="font-size: 22px;text-align: center; margin:30px 0 30px 0;">第三部分 计算的极限</div>

+ 乔姆斯基层次和DSL：计算器的故事，SQL和HTML
+ 迭代和递归：过程式vs函数式、寄存器vs栈、指令序列vs数据流
+ 匿名函数和**不动点组合子**（重点讲Y组合子）
+ 丘奇-图灵论题：brainfuck的Scheme实现
+ **停机问题**

# 3.1 语言的层次

![自动机层次](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Automata_theory.svg/320px-Automata_theory.svg.png)

> - 正则语言/文法（3）-有限状态自动机
- 上下文无关语言/文法（2）-下推自动机
- 上下文有关语言/文法（1）-线性有界图灵机
- 递归可枚举语言/短语结构文法（0）-图灵机

问题：正则表达式能处理中缀算术表达式吗？HTML为什么没有循环？启示？

递归可枚举语言为什么这么厉害？自然过渡到下一章，同时承接2.2悬而未决的除法问题。

# 3.2 递归：语言的力量之源

+ 首先讲递归和迭代的区别和联系（栈vs寄存器）
+ 然后简单提μ-递归函数（递归论的问题）
+ 自相似数据结构（列表）和数学归纳法
+ SICP里面颠覆三观的求最大和问题，以及多步递归与多个寄存器、时域平移的关系
+ 提Ackermann函数（典型的非原始递归函数，无法迭代实现）

> 阶乘的两种写法：

```:js
// 迭代写法
function fact_iter(n, product) {
    return (n === 0) ? product : fact_iter((n-1), n*product);
}
// 递归写法
function fact_rec(n) {
    return (n === 0) ? 1 : n * fact_rec(n-1);
}
```
> : <button id="js1" onclick="try{alert(fact_iter(10,1));}catch(err){alert(err);}" class="md-button">执行fact_iter(10,1)</button>

> : <button id="js1" onclick="try{alert(fact_rec(10));}catch(err){alert(err);}" class="md-button">执行fact_rec(10)</button>

# 3.3 匿名函数和不动点组合子

<code id="scheme3" style="display:none;">(display "10的阶乘：") (newline) (display (((lambda (S) ((lambda (x) (S (lambda (y) ((x x) y)))) (lambda (x) (S (lambda (y) ((x x) y)))))) (lambda (f) (lambda (n) (if (= n 0) 1 (* n (f (- n 1))))))) 10))</code>

> **示例**：使用应用序Y组合子和匿名高阶函数，实现递归

```:lisp
(display "10的阶乘：")
(((lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y))))))
 (lambda (f)
     (lambda (n)
       (if (= n 0)
           1
           (* n (f (- n 1))))))) 10)
```
> : <button id="js00" onclick="try{alert(mrRun(getCode('scheme3')));}catch(err){alert(err);}" class="md-button">执行</button>

# 3.4 丘奇-图灵论题

+ 简单介绍Brainfuck，以及用Scheme写的Brainfuck解释器
+ 呼应2.4内容，指出计算能力受限于层层嵌套的通用机，无法突破（也就是说，通用性定理意味着找不到比图灵机更强的系统），引出下一节

# 3.5 停机问题

> 使用以下代码说明什么是“部分可计算”：

```:js
function foo(array, index) {
    if(index === 100) {
        return 'Surprise!';
    }
    else {
        return foo(array, array[index]);
    }
}
```

> 请指定array=
<textarea id="input" style="-webkit-appearance:none; font-size: 13px;line-height: 23px;height: 30px;border: 1px solid #66ccff;border-radius: 0;padding: 3px; display: block; margin: 10px auto 10px auto;width: 90%;resize: none;">\[1,2,3,4,100\]</textarea>

> : <button id="js1" onclick="try{alert(foo(JSON.parse($('#input').val()),0));}catch(err){alert(err);}" class="md-button">点击执行</button>

如果函数终止，则弹出“Surprise！”；否则，会弹出栈溢出的警告。

<div style="font-size: 22px;text-align: center; margin:30px 0 30px 0;">第四部分 无处不在的复杂</div>

# 4.1 理解复杂

+ 线性系统vs非线性系统：确定性和混沌（初值敏感不等于不确定）
+ SKI组合子系统、标签系统、元胞自动机（GoL）等图灵等价机器
+ 计算复杂度（大O标记法、柯氏复杂度等）：旅行商问题及其近似算法

# 4.2 大写的计算：向自然学习

+ 动力学和统计学：钟表的启示、麦克斯韦妖
+ 广义计算：存在于生命系统和自然系统中的计算
+ 启发式算法：作为黑盒的复杂系统，好用但难以解释

# 尾声

+ 对“计算”的理解：中值滤波和均值滤波
+ 统计学智能/逻辑学智能/控制论智能…如何统一？三方面都要有
+ 知识与逻辑，知识（数据）甚至更重要——统计学习能够更好地处理“复杂”
+ 自然语言和物理现象归根结底是统计学的——在大的层面上才体现出逻辑性
+ 哥德尔证明的启示：创造性与心灵
+ 危机就是机会：矛盾是动力
+ 东西文化的碰撞：分析、理性、精确——基础研究和原创性研究
+ 我们可以不用；我们不能不懂：无用之大用

## 一些私货：为什么要讲这些东西

我是在高二的时候开始入门“专业”编程的。高中入学前，我在数学教材必修一上第一次发现了“图形计算器”这种东西，于是在淘宝上入手了一部卡西欧的fx-9750GII，并且给它刷了9860的固件，使其支持自然书写显示。图形计算器的一大特性是可编程，这正是我们刚刚提到的，计算器与计算机有什么区别，就在于能不能编程——也就是通用机的能力。当时，我有VB的一些基础，所以在计算器上写了不少小东西，像什么计算太阳月亮方位的、用曲线积分计算曲线长度的，等等。十几年前的文曲星更强大，记得他们用的语言叫什么LAVA，还培养出了一大批学生程序员，孕育出了英雄坛说这样的风靡一时的游戏。可惜那个时候我还小，当时完全不知道。可见，同好和同行之间的交流是多么重要。

计算器玩多了之后，高二的某一天突发奇想，想自己写一个“计算器”试试。用编译原理的观点来看，实际上就是个中缀式的解释器，这在CS的科班中是必做的东西。为了做这个计算器，我选择了~世界上最好的编程语言~JAVA，甚至买了一本今天看来很垃圾的教材，在晚自习的时候偷偷看。研究了一个月，试图用OO的方法写这个计算器，但是写出来的东西乱七八糟，完全不忍卒读。当时我也意识到了，面向对象这种东西如果不静下心来学，是很难懂的，当然我觉得那本国人编的垃圾教材也应该背锅。后来我转向C语言，慢慢就上道了。当时的我，也不懂啥叫词法分析语法分析，更不懂什么移入-归约、什么下推自动机。记得当时用的就是最trivial的括号匹配计数，硬是做出了这个中缀式计算器，支持中缀双目运算符和前缀的数学函数调用。当时是2012年7月，我印象很深刻。

后来我意识到，也许可以在此基础上做一个解释器。当时因为是高三，也没有很多时间去上网，所以很多东西只能靠想象。当时不懂什么是编译原理，连数据结构也不懂，就这样磕磕绊绊地做了半年，终于在2012年12月，完成了一个非常简陋的类似于BASIC的解释器。我给它命名为Inf，尽管我当时对“无穷”与解释器的关系并不了解，因为有别的原因。

高考后，终于知道“栈”这种数据结构，大一的时候完善了这个Inf解释器，使其支持递归。后来，便不再开发了，因为确实很简陋。通过做这个解释器，我从无到有地理解了一些现在看来很重要的概念，例如“环境”的概念。更重要的意义是，高二突然冒出的那个想法，成了我至今为止想要理解“计算本质”的最最原始的动力。

所以今天，我准备了这次培训，希望和各位分享一下我的学习历程。

再次恳请感兴趣的同事批评、指导、指正！谢谢！

------

# 参考资料

+ 侯世达: [哥德尔、艾舍尔、巴赫——集异璧之大成](https://book.douban.com/subject/1291204/). 商务印书馆
+ Tom Stuart: [计算的本质](https://book.douban.com/subject/26148763/). 人民邮电出版社
+ 胡作玄: [第三次数学危机](https://book.douban.com/subject/1847799/). 四川人民出版社
+ 欧内斯特·内格尔, 詹姆士 R. 纽曼: [哥德尔证明](https://book.douban.com/subject/3029210/). 中国人民大学出版社
+ Martin Davis: [逻辑的引擎](https://book.douban.com/subject/1391740/). 湖南科学技术出版社
+ D. P. Friedman, M. Wand: [Essentials of Programming Languages](http://www.eopl3.com/)
+ 梅拉妮·米歇尔: [复杂](https://book.douban.com/subject/6749832/). 湖南科学技术出版社
+ Charles Petzold: [编码](https://book.douban.com/subject/4822685/). 电子工业出版社
+ Charles Petzold: [图灵的秘密](https://book.douban.com/subject/10779604/). 人民邮电出版社
+ 埃尔文·薛定谔: [生命是什么](https://book.douban.com/subject/26309060/). 商务印书馆
+ 伯特兰·罗素: [数理哲学导论](https://book.douban.com/subject/1248122/). 商务印书馆
+ William J. Cook: [迷茫的旅行商](https://book.douban.com/subject/25713498/). 人民邮电出版社



#!css
canvas {
    display: block;
    border: none;
    box-shadow: 0 2px 5px 0 rgba(0,0,0,0.2);
    margin: 15px auto 15px auto;
}
#!js

#script:./js/mikurec2.js

function fact_iter(n, product) {
    return (n === 0) ? product : fact_iter((n-1), n*product);
}
function fact_rec(n) {
    return (n === 0) ? 1 : n * fact_rec(n-1);
}
function foo(array, index) {
    if(index === 100) {
        return "Surprise!";
    }
    else {
        return foo(array, array[index]);
    }
}
function getCode(divId) {
    return $('#' + divId).html();
}
