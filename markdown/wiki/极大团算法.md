#!title:    极大团算法
#!date:     2018-11-23
#!authors:  Mikukonai
#!cover:    
#!type:     C
#!tags:     

#!content

# 引言

团（clique）指的是无向图的完全子图。其中，如果某个团不是任何其他团的子图，则为**极大团**。顶点数最多的团，称为**最大团**。

求取最大团/极大团的算法往往需要耗费指数级时间，目前尚未找到多项式时间的算法，因而是NP完全问题。使用启发式算法，可以减少一部分时间复杂度，但是没有本质提升。

团算法在许多领域都有用处。例如，朋友圈实际上就是团。在生物信息学中，需要利用团算法解决重复序列的问题。前段时间在工作中遇到了类似的问题，因此在这里写个简单的Demo，记录一下。

# 举例演示

现有一段核酸序列，其上有限制酶A的切割位点3个。使用A处理后，可得到10种长短不一的片段（如下图）。问可以得到的互不重叠的片段组合有哪些？

![ ](./image/wiki/C/dna-cut.png)

从0~9给片段编号，显然，[0,1,2,3]是可能的一种方案，因为它们**两两都没有重叠**。因此，可以将片段间的“不重叠”关系构造成图，求出这个图的所有极大团，就是所有可能的互不重叠的片段组合了。（注：“不重叠”关系是反自反、对称、反传递的关系，因而体现为无向图。）

使用JavaScript实现，计算得到极大团为：<span id="maximal_cliques"></span>

# 极大团算法

最简单的方法当然是暴力地穷举出所有子图，然后逐一检查，这一方案的时间复杂度是指数级的。但是，有很多“显然”的情况是不需要枚举的，这就是剪枝。

于是很容易想到一个策略：首先假设最开始的团是空的，从0节点开始，将其加入候选团，然后遍历剩余所有节点：如果某节点可以与候选团形成团，则加入候选团，然后继续遍历剩余节点；如果不可以（剪枝），就抛弃掉，并回溯到上一个成团的节点。这实际上是按照深度优先的策略对解空间树进行遍历的过程。

按照这个方法，可以求解出所有可能的团，称为平凡团。如果需要求极大团，则对所有的平凡团按照子集关系进行合并，最终留下互不包含的若干个团，即为极大团。取顶点数最多的（若干个）极大团，即为最大团。

# 后记

极大团算法其实是比较困难的算法，难就难在时间复杂度超高，问题规模稍微大一点就不能用。作为NP完全问题，此问题在理论上的意义也很重大。不过暂时没有兴趣进一步研究这个问题，浅尝辄止就好。

问题的关键在于，如何把新遇到的问题，转化到已有的问题上去。

# 参考资料

+ [最大团问题和图的m着色问题](https://blog.csdn.net/liufeng_king/article/details/8781554)
+ [The Clique Algorithm](http://www.dharwadker.org/clique/)

#!style

#!script

#!script:./script/clique.js

const a = [
//   0  1  2  3  4  5  6  7  8  9
    [0, 1, 1, 1, 0, 1, 1, 0, 1, 0],
    [1, 0, 1, 1, 0, 1, 0, 0, 0, 0],
    [1, 1, 0, 1, 1, 0, 0, 0, 0, 0],
    [1, 1, 1, 0, 1, 0, 1, 1, 0, 0],
    [0, 0, 1, 1, 0, 1, 0, 0, 0, 0],
    [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],
    [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];
let g = new Graph(10, a);
$('#maximal_cliques').html(JSON.stringify(g.calculateMaximalCliques()));

